fragment_downloaded_cb({"url": "javascript/threads.html#glibcond", "fragment": "GLib.Cond \nThe GLib.Cond struct is an opaque data structure that represents a condition. Threads can block on a GLib.Cond if they find a certain condition to be false. If other threads change the state of this condition they signal the GLib.Cond and that causes the waiting threads to be woken up. \nConsider the following example of a shared variable. One or more threads can wait for data to be published to the variable and when another thread publishes the data it can signal one of the waiting threads to wake up to collect the data. \nHere is an example for using GCond to block a thread until a condition is satisfied \nWhenever a thread calls pop_data now it will wait until current_data is non NULL i.e. until some other thread has called push_data. \nThe example shows that use of a condition variable must always be paired with a mutex. Without the use of a mutex there would be a race between the check of current_data by the while loop in pop_data and waiting. Specifically another thread could set current_data after the check and signal the cond with nobody waiting on it before the first thread goes to sleep. GLib.Cond is specifically useful for its ability to release the mutex and go to sleep atomically. \nIt is also important to use the GLib.Cond.prototype.wait and GLib.Cond.prototype.wait_until functions only inside a loop which checks for the condition to be true. See GLib.Cond.prototype.wait for an explanation of why the condition may not be true even after it returns. \nIf a GLib.Cond is allocated in static storage then it can be used without initialisation. Otherwise you should call GLib.Cond.prototype.init on it and GLib.Cond.prototype.clear when done. \nA GLib.Cond should only be accessed via the g_cond_ functions. \n"});