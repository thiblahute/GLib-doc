fragment_downloaded_cb({"url": "javascript/iochannels.html#g_io_channel_set_encoding", "fragment": "GLib.IOChannel.prototype.set_encoding \nSets the encoding for the input output of the channel. The internal encoding is always UTF The default encoding for the external file is UTF \nThe encoding null is safe to use with binary data. \nThe encoding can only be set if one of the following conditions is true \nThe channel was just created and has not been written to or read from yet. \nThe channel is write only. \nThe channel is a file and the file pointer was just repositioned by a call to GLib.IOChannel.prototype.seek_position. This flushes all the internal buffers. \nThe current encoding is null or UTF \nOne of the new API read functions has just returned GLib.IOStatus.prototype.eof or in the case of GLib.IOChannel.prototype.read_to_end GLib.IOStatus.prototype.normal \nOne of the functions GLib.IOChannel.prototype.read_chars or GLib.IOChannel.prototype.read_unichar has returned GLib.IOStatus.prototype.again or GLib.IOStatus.prototype.error. This may be useful in the case of GLib.ConvertError.prototype.illegal_sequence. Returning one of these statuses from GLib.IOChannel.prototype.read_line GLib.IOChannel.prototype.read_line_string or GLib.IOChannel.prototype.read_to_end does not guarantee that the encoding can be changed. \nChannels which do not meet one of the above conditions cannot call GLib.IOChannel.prototype.seek_position with an offset of GLib.SeekType.prototype.cur and if they are seekable cannot call GLib.IOChannel.prototype.write_chars after calling one of the API read functions. \nReturn Value GLib.IOStatus.prototype.normal if the encoding was successfully set \n"});