fragment_downloaded_cb({"url": "javascript/regex-syntax.html#page-description", "fragment": "GRegex regular expression details \nAbsolute and relative back references \nSquare brackets and character classes \nAtomic grouping and possessive quantifiers \nChecking for a used subpattern by number \nChecking for a used subpattern by name \nChecking for pattern recursion \nDefining subpatterns for use by reference only \nA regular expression is a pattern that is matched against a string from left to right. Most characters stand for themselves in a pattern and match the corresponding characters in the string. As a trivial example the pattern \nmatches a portion of a string that is identical to itself. When caseless matching is specified the G_REGEX_CASELESS flag letters are matched independently of case. \nThe power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of metacharacters which do not stand for themselves but instead are interpreted in some special way. \nThere are two different sets of metacharacters those that are recognized anywhere in the pattern except within square brackets and those that are recognized in square brackets. Outside square brackets the metacharacters are as follows \nPart of a pattern that is in square brackets is called a character class In a character class the only metacharacters are \nThe sequence g followed by a positive or negative number optionally enclosed in braces is an absolute or relative back reference. Back references are discussed later following the discussion of parenthesized subpatterns. \nAn opening square bracket introduces a character class terminated by a closing square bracket. A closing square bracket on its own is not special. If a closing square bracket is required as a member of the class it should be the first data character in the class after an initial circumflex if present or escaped with a backslash. \nA character class matches a single character in the string. A matched character must be in the set of characters defined by the class unless the first character in the class definition is a circumflex in which case the string character must not be in the set defined by the class. If a circumflex is actually required as a member of the class ensure it is not the first character or escape it with a backslash. \nFor example the character class aeiou matches any lower case vowel while aeiou matches any character that is not a lower case vowel. Note that a circumflex is just a convenient notation for specifying the characters that are in the class by enumerating those that are not. A class that starts with a circumflex is not an assertion it still consumes a character from the string and therefore it fails if the current pointer is at the end of the string. \nIn UTF mode characters with values greater than can be included in a class as a literal string of bytes or by using the x escaping mechanism. \nWhen caseless matching is set any letters in a class represent both their upper case and lower case versions so for example a caseless aeiou matches A as well as a and a caseless aeiou does not match A whereas a caseful version would. \nCharacters that might indicate line breaks are never treated in any special way when matching character classes whatever line ending sequence is in use and whatever setting of the G_REGEX_DOTALL and G_REGEX_MULTILINE options is used. A class such as a always matches one of these characters. \nThe minus hyphen character can be used to specify a range of characters in a character class. For example d m matches any letter between d and m inclusive. If a minus character is required in a class it must be escaped with a backslash or appear in a position where it cannot be interpreted as indicating a range typically as the first or last character in the class. \nIt is not possible to have the literal character as the end character of a range. A pattern such as W is interpreted as a class of two characters W and followed by a literal string so it would match W46 or However if the is escaped with a backslash it is interpreted as the end of range so W is interpreted as a class containing a range followed by two other characters. The octal or hexadecimal representation of can also be used to end a range. \nRanges operate in the collating sequence of character values. They can also be used for characters specified numerically for example In UTF mode ranges can include characters whose values are greater than for example x x ff \nThe character types d D p P s S w and W may also appear in a character class and add the characters that they match to the class. For example dABCDEF matches any hexadecimal digit. A circumflex can conveniently be used with the upper case character types to specify a more restricted set of characters than the matching lower case type. For example the class W_ matches any letter or digit but not underscore. \nThe only metacharacters that are recognized in character classes are backslash hyphen only where it can be interpreted as specifying a range circumflex only at the start opening square bracket only when it can be interpreted as introducing a POSIX class name see the next section and the terminating closing square bracket. However escaping other non alphanumeric characters does no harm. \nWith both maximizing greedy and minimizing ungreedy or lazy repetition failure of what follows normally causes the repeated item to be re evaluated to see if a different number of repeats allows the rest of the pattern to match. Sometimes it is useful to prevent this either to change the nature of the match or to cause it fail earlier than it otherwise might when the author of the pattern knows there is no point in carrying on. \nConsider for example the pattern d foo when applied to the string \nAfter matching all digits and then failing to match foo the normal action of the matcher is to try again with only digits matching the d item and then with and so on before ultimately failing. Atomic grouping a term taken from Jeffrey Friedl s book provides the means for specifying that once a subpattern has matched it is not to be re evaluated in this way. \nIf we use atomic grouping for the previous example the matcher give up immediately on failing to match foo the first time. The notation is a kind of special parenthesis starting with as in this example \nThis kind of parenthesis locks up the part of the pattern it contains once it has matched and a failure further into the pattern is prevented from backtracking into it. Backtracking past it to previous items however works as normal. \nAn alternative description is that a subpattern of this type matches the string of characters that an identical standalone pattern would match if anchored at the current point in the string. \nAtomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So while both d and d are prepared to adjust the number of digits they match in order to make the rest of the pattern match d can only match an entire sequence of digits. \nAtomic groups in general can of course contain arbitrarily complicated subpatterns and can be nested. However when the subpattern for an atomic group is just a single repeated item as in the example above a simpler notation called a possessive quantifier can be used. This consists of an additional character following a quantifier. Using this notation the previous example can be rewritten as \nPossessive quantifiers are always greedy the setting of the G_REGEX_UNGREEDY option is ignored. They are a convenient notation for the simpler forms of atomic group. However there is no difference in the meaning of a possessive quantifier and the equivalent atomic group though there may be a performance difference possessive quantifiers should be slightly faster. \nThe possessive quantifier syntax is an extension to the Perl syntax. It was invented by Jeffrey Friedl in the first edition of his book and then implemented by Mike McCloskey in Sun s Java package. It ultimately found its way into Perl at release \nGRegex has an optimization that automatically possessifies certain simple pattern constructs. For example the sequence A B is treated as A B because there is no point in backtracking into a sequence of A s when B must follow. \nWhen a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times the use of an atomic group is the only way to avoid some failing matches taking a very long time indeed. The pattern \nmatches an unlimited number of substrings that either consist of non digits or digits enclosed in followed by either or When it matches it runs quickly. However if it is applied to \nit takes a long time before reporting failure. This is because the string can be divided between the internal D repeat and the external repeat in a large number of ways and all have to be tried. The example uses rather than a single character at the end because GRegex has an optimization that allows for fast failure when a single character is used. It remember the last single character that is required for a match and fail early if it is not present in the string. If the pattern is changed so that it uses an atomic group like this \nsequences of non digits cannot be broken and failure happens quickly. \nIf the text between the parentheses consists of a sequence of digits the condition is true if the capturing subpattern of that number has previously matched. \nConsider the following pattern which contains non significant white space to make it more readable assume the G_REGEX_EXTENDED and to divide it into three parts for ease of discussion \nThe first part matches an optional opening parenthesis and if that character is present sets it as the first captured substring. The second part matches one or more characters that are not parentheses. The third part is a conditional subpattern that tests whether the first set of parentheses matched or not. If they did that is if string started with an opening parenthesis the condition is true and so the yes pattern is executed and a closing parenthesis is required. Otherwise since no pattern is not present the subpattern matches nothing. In other words this pattern matches a sequence of non parentheses optionally enclosed in parentheses. \nPerl uses the syntax name or name to test for a used subpattern by name the Python syntax name is also recognized. However there is a possible ambiguity with this syntax because subpattern names may consist entirely of digits. GRegex looks first for a named subpattern if it cannot find one and the name consists entirely of digits GRegex looks for a subpattern of that number which must be greater than zero. Using subpattern names that consist entirely of digits is not recommended. \nRewriting the above example to use a named subpattern gives this \nIf the condition is the string R and there is no subpattern with the name R the condition is true if a recursive call to the whole pattern or any subpattern has been made. If digits or a name preceded by ampersand follow the letter R for example \nthe condition is true if the most recent recursion is into the subpattern whose number or name is given. This condition does not check the entire recursion stack. \nAt top level all these recursion test conditions are false. Recursive patterns are described below. \nIf the condition is the string DEFINE and there is no subpattern with the name DEFINE the condition is always false. In this case there may be only one alternative in the subpattern. It is always skipped if control reaches this point in the pattern the idea of DEFINE is that it can be used to define subroutines that can be referenced from elsewhere. The use of subroutines is described below. For example a pattern to match an IPv4 address could be written like this ignore whitespace and line breaks \nThe first part of the pattern is a DEFINE group inside which a another group named byte is defined. This matches an individual component of an IPv4 address a number less than When matching takes place this part of the pattern is skipped because DEFINE acts like a false condition. \nThe rest of the pattern uses references to the named group to match the four dot separated components of an IPv4 address insisting on a word boundary at each end. \n"});