fragment_downloaded_cb({"url": "javascript/regex-syntax.html#recursive-patterns", "fragment": "Recursive patterns \nConsider the problem of matching a string in parentheses allowing for unlimited nested parentheses. Without the use of recursion the best that can be done is to use a pattern that matches up to some fixed depth of nesting. It is not possible to handle an arbitrary nesting depth. \nFor some time Perl has provided a facility that allows regular expressions to recurse amongst other things It does this by interpolating Perl code in the expression at run time and the code can refer to the expression itself. A Perl pattern using code interpolation to solve the parentheses problem can be created like this \nThe p item interpolates Perl code at run time and in this case refers recursively to the pattern in which it appears. \nObviously GRegex cannot support the interpolation of Perl code. Instead it supports special syntax for recursion of the entire pattern and also for individual subpattern recursion. This kind of recursion was introduced into Perl at release \nA special item that consists of followed by a number greater than zero and a closing parenthesis is a recursive call of the subpattern of the given number provided that it occurs inside that subpattern. If not it is a subroutine call which is described in the next section. The special item R or is a recursive call of the entire regular expression. \nIn GRegex like Python but unlike Perl a recursive subpattern call is always treated as an atomic group. That is once it has matched some of the subject string it is never re entered even if it contains untried alternatives and there is a subsequent matching failure. \nThis pattern solves the nested parentheses problem assume the G_REGEX_EXTENDED option is set so that white space is ignored \nFirst it matches an opening parenthesis. Then it matches any number of substrings which can either be a sequence of non parentheses or a recursive match of the pattern itself that is a correctly parenthesized substring Finally there is a closing parenthesis. \nIf this were part of a larger pattern you would not want to recurse the entire pattern so instead you could use this \nWe have put the pattern into parentheses and caused the recursion to refer to them instead of the whole pattern. In a larger pattern keeping track of parenthesis numbers can be tricky. It may be more convenient to use named parentheses instead. The Perl syntax for this is name GRegex also supports the P name syntac. We could rewrite the above example as follows \nIf there is more than one subpattern with the same name the earliest one is used. This particular example pattern contains nested unlimited repeats and so the use of atomic grouping for matching strings of non parentheses is important when applying the pattern to strings that do not match. For example when this pattern is applied to \nit yields no match quickly. However if atomic grouping is not used the match runs for a very long time indeed because there are so many different ways the and repeats can carve up the string and all have to be tested before failure can be reported. \nAt the end of a match the values set for any capturing subpatterns are those from the outermost level of the recursion at which the subpattern value is set. If the pattern above is matched against \nthe value for the capturing parentheses is ef which is the last value taken on at the top level. If additional parentheses are added giving \nthe string they capture is ab cd ef the contents of the top level parentheses. \nDo not confuse the R item with the condition R which tests for recursion. Consider this pattern which matches text in angle brackets allowing for arbitrary nesting. Only digits are allowed in nested brackets that is when recursing whereas any characters are permitted at the outer level. \nIn this pattern R is the start of a conditional subpattern with two different alternatives for the recursive and non recursive cases. The R item is the actual recursive call. \n"});