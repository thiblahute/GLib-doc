fragment_downloaded_cb({"url": "python/main.html#glibmain_depth", "fragment": "GLib.main_depth \nReturns the depth of the stack of calls to GLib.MainContext.dispatch on any GLib.MainContext in the current thread. That is when called from the toplevel it gives When called from within a callback from GLib.MainContext.iteration or GLib.MainLoop.run etc. it returns When called from within a callback to a recursive call to GLib.MainContext.iteration it returns And so forth. \nThis function is useful in a situation like the following Imagine an extremely simple garbage collected system. \nThis works from an application however if you want to do the same thing from a library it gets more difficult since you no longer control the main loop. You might think you can simply use an idle function to make the call to free_allocated_memory but that doesn t work since the idle function could be called from a recursive callback. This can be fixed by using GLib.main_depth \nThere is a temptation to use GLib.main_depth to solve problems with reentrancy. For instance while waiting for data to be received from the network in response to a menu item the menu item might be selected again. It might seem that one could make the menu item s callback return immediately and do nothing if GLib.main_depth returns a value greater than However this should be avoided since the user then sees selecting the menu item do nothing. Furthermore you ll find yourself adding these checks all over your code since there are doubtless many many things that the user could do. Instead you can use the following techniques \nUse gtk_widget_set_sensitive or modal dialogs to prevent the user from interacting with elements while the main loop is recursing. \nAvoid main loop recursion in situations where you can t handle arbitrary callbacks. Instead structure your code so that you simply return to the main loop and then get called again when there is more work to do. \n"});