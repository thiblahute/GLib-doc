fragment_downloaded_cb({"url": "python/gregex.html#glibregexmatch_all_full", "fragment": "GLib.Regex.match_all_full \nUsing the standard algorithm for regular expression matching only the longest match in the string is retrieved it is not possible to obtain all the available matches. For instance matching against the pattern you get \nThis function uses a different algorithm called DFA i.e. deterministic finite automaton so it can retrieve all the possible matches all starting at the same point in the string. For instance matching against the pattern you would obtain three matches and \nThe number of matched strings is retrieved using GLib.MatchInfo.get_match_count. To obtain the matched strings and their position you can use respectively GLib.MatchInfo.fetch and GLib.MatchInfo.fetch_pos. Note that the strings are returned in reverse order of length that is the longest matching string is given first. \nNote that the DFA algorithm is slower than the standard one and it is not able to capture substrings so backreferences do not work. \nSetting start_position differs from just passing over a shortened string and setting GLib.RegexMatchFlags.notbol in the case of a pattern that begins with any kind of lookbehind assertion such as b \nA GLib.MatchInfo structure used to get information on the match is stored in match_info if not None. Note that if match_info is not None then it is created even if the function returns False i.e. you must free it regardless if regular expression actually matched. \nstring is not copied and is used in GLib.MatchInfo internally. If you use any GLib.MatchInfo method except GLib.MatchInfo.free after freeing or modifying string then the behaviour is undefined. \n"});