fragment_downloaded_cb({"url": "python/gregex.html#glibmatchinfois_partial_match", "fragment": "GLib.MatchInfo.is_partial_match \nUsually if the string passed to g_regex_match matches as far as it goes but is too short to match the entire pattern False is returned. There are circumstances where it might be helpful to distinguish this case from other cases in which there is no match. \nConsider for example an application where a human is required to type in data for a field with specific formatting requirements. An example might be a date in the form ddmmmyy defined by the pattern d d jan feb mar apr may jun jul aug sep oct nov dec d d If the application sees the user s keystrokes one by one and can check that what has been typed so far is potentially valid it is able to raise an error as soon as a mistake is made. \nGRegex supports the concept of partial matching by means of the GLib.RegexMatchFlags.partial_soft and GLib.RegexMatchFlags.partial_hard flags. When they are used the return code for GLib.Regex.match or GLib.Regex.match_full is as usual True for a complete match False otherwise. But when these functions return False you can check if the match was partial calling GLib.MatchInfo.is_partial_match. \nThe difference between GLib.RegexMatchFlags.partial_soft and GLib.RegexMatchFlags.partial_hard is that when a partial match is encountered with GLib.RegexMatchFlags.partial_soft matching continues to search for a possible complete match while with GLib.RegexMatchFlags.partial_hard matching stops at the partial match. When both GLib.RegexMatchFlags.partial_soft and GLib.RegexMatchFlags.partial_hard are set the latter takes precedence. \nThere were formerly some restrictions on the pattern for partial matching. The restrictions no longer apply. \nSee pcrepartial for more information on partial matching. \n"});