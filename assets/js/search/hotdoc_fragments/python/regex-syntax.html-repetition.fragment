fragment_downloaded_cb({"url": "python/regex-syntax.html#repetition", "fragment": "Repetition \nRepetition is specified by quantifiers which can follow any of the following items \na literal data character \nthe dot metacharacter \nthe C escape sequence \nthe X escape sequence in UTF mode \nthe R escape sequence \nan escape such as d that matches a single character \na character class \na back reference see next section \na parenthesized subpattern unless it is an assertion \nThe general repetition quantifier specifies a minimum and maximum number of permitted matches by giving the two numbers in curly brackets braces separated by a comma. The numbers must be less than and the first must be less than or equal to the second. For example \nmatches zz zzz or zzzz A closing brace on its own is not a special character. If the second number is omitted but the comma is present there is no upper limit if the second number and the comma are both omitted the quantifier specifies an exact number of required matches. Thus \nmatches at least successive vowels but may match many more while \nmatches exactly digits. An opening curly bracket that appears in a position where a quantifier is not allowed or one that does not match the syntax of a quantifier is taken as a literal character. For example is not a quantifier but a literal string of four characters. \nIn UTF mode quantifiers apply to UTF characters rather than to individual bytes. Thus for example x matches two UTF characters each of which is represented by a two byte sequence. Similarly X matches three Unicode extended sequences each of which may be several bytes long and they may be of different lengths \nThe quantifier is permitted causing the expression to behave as if the previous item and the quantifier were not present. \nFor convenience the three most common quantifiers have single character abbreviations \nIt is possible to construct infinite loops by following a subpattern that can match no characters with a quantifier that has no upper limit for example \nBecause there are cases where this can be useful such patterns are accepted but if any repetition of the subpattern does in fact match no characters the loop is forcibly broken. \nBy default the quantifiers are greedy that is they match as much as possible up to the maximum number of permitted times without causing the rest of the pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between and and within the comment individual and characters may appear. An attempt to match C comments by applying the pattern \nto the string \nfails because it matches the entire string owing to the greediness of the item. \nHowever if a quantifier is followed by a question mark it ceases to be greedy and instead matches the minimum number of times possible so the pattern \ndoes the right thing with the C comments. The meaning of the various quantifiers is not otherwise changed just the preferred number of matches. Do not confuse this use of question mark with its use as a quantifier in its own right. Because it has two uses it can sometimes appear doubled as in \nwhich matches one digit by preference but can match two if that is the only way the rest of the pattern matches. \nIf the G_REGEX_UNGREEDY flag is set the quantifiers are not greedy by default but individual ones can be made greedy by following them with a question mark. In other words it inverts the default behaviour. \nWhen a parenthesized subpattern is quantified with a minimum repeat count that is greater than or with a limited maximum more memory is required for the compiled pattern in proportion to the size of the minimum or maximum. \nIf a pattern starts with or and the G_REGEX_DOTALL flag is set thus allowing the dot to match newlines the pattern is implicitly anchored because whatever follows will be tried against every character position in the string so there is no point in retrying the overall match at any position after the first. GRegex normally treats such a pattern as though it were preceded by A. \nIn cases where it is known that the string contains no newlines it is worth setting G_REGEX_DOTALL in order to obtain this optimization or alternatively using to indicate anchoring explicitly. \nHowever there is one situation where the optimization cannot be used. When is inside capturing parentheses that are the subject of a backreference elsewhere in the pattern a match at the start may fail where a later one succeeds. Consider for example \nIf the string is xyz123abc123 the match point is the fourth character. For this reason such a pattern is not implicitly anchored. \nWhen a capturing subpattern is repeated the value captured is the substring that matched the final iteration. For example after \nhas matched tweedledum tweedledee the value of the captured substring is tweedledee However if there are nested capturing subpatterns the corresponding captured values may have been set in previous iterations. For example after \nmatches aba the value of the second captured substring is b \n"});