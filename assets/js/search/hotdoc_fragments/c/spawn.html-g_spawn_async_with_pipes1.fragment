fragment_downloaded_cb({"url": "c/spawn.html#g_spawn_async_with_pipes1", "fragment": "g_spawn_async_with_pipes \nExecutes a child program asynchronously your program will not block waiting for the child to exit The child program is specified by the only argument that must be provided argv. argv should be a NULL terminated array of strings to be passed as the argument vector for the child. The first string in argv is of course the name of the program to execute. By default the name of the program must be a full path. If flags contains the G_SPAWN_SEARCH_PATH flag the PATH environment variable is used to search for the executable. If flags contains the G_SPAWN_SEARCH_PATH_FROM_ENVP flag the PATH variable from envp is used to search for the executable. If both the G_SPAWN_SEARCH_PATH and G_SPAWN_SEARCH_PATH_FROM_ENVP flags are set the PATH variable from envp takes precedence over the environment variable. \nIf the program name is not a full path and G_SPAWN_SEARCH_PATH flag is not used then the program will be run from the current directory or working_directory if specified this might be unexpected or even dangerous in some cases when the current directory is world writable. \nOn Windows note that all the string or string vector arguments to this function and the other g_spawn functions are in UTF the GLib file name encoding. Unicode characters that are not part of the system codepage passed in these arguments will be correctly available in the spawned program only if it uses wide character API to retrieve its command line. For C programs built with Microsoft s tools it is enough to make the program have a wmain instead of main. wmain has a wide character argument vector as parameter. \nAt least currently mingw doesn t support wmain so if you use mingw to develop the spawned program it should call g_win32_get_command_line to get arguments in UTF \nOn Windows the low level child process creation API CreateProcess doesn t use argument vectors but a command line. The C runtime library s spawn family of functions which g_spawn_async_with_pipes eventually calls paste the argument vector elements together into a command line and the C runtime startup code does a corresponding reconstruction of an argument vector from the command line to be passed to main. Complications arise when you have argument vector elements that contain spaces of double quotes. The spawn functions don t do any quoting or escaping but on the other hand the startup code does do unquoting and unescaping in order to enable receiving arguments with embedded spaces or double quotes. To work around this asymmetry g_spawn_async_with_pipes will do quoting and escaping on argument vector elements that need it before calling the C runtime spawn function. \nThe returned child_pid on Windows is a handle to the child process not its identifier. Process handles and process identifiers are different concepts on Windows. \nenvp is a NULL terminated array of strings where each string has the form KEY VALUE. This will become the child s environment. If envp is NULL the child inherits its parent s environment. \nflags should be the bitwise OR of any flags you want to affect the function s behaviour. The G_SPAWN_DO_NOT_REAP_CHILD means that the child will not automatically be reaped you must use a child watch to be notified about the death of the child process. Eventually you must call g_spawn_close_pid on the child_pid in order to free resources which may be associated with the child process. On Unix using a child watch is equivalent to calling waitpid or handling the SIGCHLD signal manually. On Windows calling g_spawn_close_pid is equivalent to calling CloseHandle on the process handle returned in child_pid See g_child_watch_add. \nG_SPAWN_LEAVE_DESCRIPTORS_OPEN means that the parent s open file descriptors will be inherited by the child otherwise all descriptors except stdin stdout stderr will be closed before calling exec in the child. G_SPAWN_SEARCH_PATH means that argv need not be an absolute path it will be looked for in the PATH environment variable. G_SPAWN_SEARCH_PATH_FROM_ENVP means need not be an absolute path it will be looked for in the PATH variable from envp. If both G_SPAWN_SEARCH_PATH and G_SPAWN_SEARCH_PATH_FROM_ENVP are used the value from envp takes precedence over the environment. G_SPAWN_STDOUT_TO_DEV_NULL means that the child s standard output will be discarded instead of going to the same location as the parent s standard output. If you use this flag standard_output must be NULL. G_SPAWN_STDERR_TO_DEV_NULL means that the child s standard error will be discarded instead of going to the same location as the parent s standard error. If you use this flag standard_error must be NULL. G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent s standard input by default the child s standard input is attached to dev null If you use this flag standard_input must be NULL. G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of argv is the file to execute while the remaining elements are the actual argument vector to pass to the file. Normally g_spawn_async_with_pipes uses argv as the file to execute and passes all of argv to the child. \nchild_setup and user_data are a function and user data. On POSIX platforms the function is called in the child after GLib has performed all the setup it plans to perform including creating pipes closing file descriptors etc. but before calling exec. That is child_setup is called just before calling exec in the child. Obviously actions taken in this function will only affect the child not the parent. \nOn Windows there is no separate fork and exec functionality. Child processes are created and run with a single API call CreateProcess. There is no sensible thing child_setup could be used for on Windows so it is ignored and not called. \nIf non NULL child_pid will on Unix be filled with the child s process ID. You can use the process ID to send signals to the child or to use g_child_watch_add or waitpid if you specified the G_SPAWN_DO_NOT_REAP_CHILD flag. On Windows child_pid will be filled with a handle to the child process only if you specified the G_SPAWN_DO_NOT_REAP_CHILD flag. You can then access the child process using the Win32 API for example wait for its termination with the WaitFor functions or examine its exit code with GetExitCodeProcess. You should close the handle with CloseHandle or g_spawn_close_pid when you no longer need it. \nIf non NULL the standard_input standard_output standard_error locations will be filled with file descriptors for writing to the child s standard input or reading from its standard output or standard error. The caller of g_spawn_async_with_pipes must close these file descriptors when they are no longer in use. If these parameters are NULL the corresponding pipe won t be created. \nIf standard_input is NULL the child s standard input is attached to dev null unless G_SPAWN_CHILD_INHERITS_STDIN is set. \nIf standard_error is NULL the child s standard error goes to the same location as the parent s standard error unless G_SPAWN_STDERR_TO_DEV_NULL is set. \nIf standard_output is NULL the child s standard output goes to the same location as the parent s standard output unless G_SPAWN_STDOUT_TO_DEV_NULL is set. \nerror can be NULL to ignore errors or non NULL to report errors. If an error is set the function returns FALSE. Errors are reported even if they occur in the child for example if the executable in argv is not found Typically the message field of returned errors should be displayed to users. Possible errors are those from the G_SPAWN_ERROR domain. \nIf an error occurs child_pid standard_input standard_output and standard_error will not be filled with valid values. \nIf child_pid is not NULL and an error does not occur then the returned process reference must be closed using g_spawn_close_pid. \nIf you are writing a GTK application and the program you are spawning is a graphical application too then you may want to use gdk_spawn_on_screen_with_pipes instead to ensure that the spawned program opens its windows on the right screen. \n"});