fragment_downloaded_cb({"url": "c/gregex.html#g_match_info_is_partial_match", "fragment": "g_match_info_is_partial_match \nUsually if the string passed to g_regex_match matches as far as it goes but is too short to match the entire pattern FALSE is returned. There are circumstances where it might be helpful to distinguish this case from other cases in which there is no match. \nConsider for example an application where a human is required to type in data for a field with specific formatting requirements. An example might be a date in the form ddmmmyy defined by the pattern d d jan feb mar apr may jun jul aug sep oct nov dec d d If the application sees the user s keystrokes one by one and can check that what has been typed so far is potentially valid it is able to raise an error as soon as a mistake is made. \nGRegex supports the concept of partial matching by means of the G_REGEX_MATCH_PARTIAL_SOFT and G_REGEX_MATCH_PARTIAL_HARD flags. When they are used the return code for g_regex_match or g_regex_match_full is as usual TRUE for a complete match FALSE otherwise. But when these functions return FALSE you can check if the match was partial calling g_match_info_is_partial_match. \nThe difference between G_REGEX_MATCH_PARTIAL_SOFT and G_REGEX_MATCH_PARTIAL_HARD is that when a partial match is encountered with G_REGEX_MATCH_PARTIAL_SOFT matching continues to search for a possible complete match while with G_REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both G_REGEX_MATCH_PARTIAL_SOFT and G_REGEX_MATCH_PARTIAL_HARD are set the latter takes precedence. \nThere were formerly some restrictions on the pattern for partial matching. The restrictions no longer apply. \nSee pcrepartial for more information on partial matching. \n"});