fragment_downloaded_cb({"url": "c/main.html#g_timeout_add_seconds_full1", "fragment": "g_timeout_add_seconds_full \nSets a function to be called at regular intervals with priority. The function is called repeatedly until it returns FALSE at which point the timeout is automatically destroyed and the function will not be called again. \nUnlike g_timeout_add this function operates at whole second granularity. The initial starting point of the timer is determined by the implementation and the implementation is expected to group multiple timers together so that they fire all at the same time. To allow this grouping the interval to the first timer is rounded and can deviate up to one second from the specified interval. Subsequent timer iterations will generally run at the specified interval. \nNote that timeout functions may be delayed due to the processing of other event sources. Thus they should not be relied on for precise timing. After each call to the timeout function the time of the next timeout is recalculated based on the current time and the given interval \nSee memory management of sources mainloop memory management for details on how to handle the return value and memory management of data. \nIf you want timing more precise than whole seconds use g_timeout_add instead. \nThe grouping of timers to fire at the same time results in a more power and CPU efficient behavior so if your timer is in multiples of seconds and you don t require the first timer exactly one second from now the use of g_timeout_add_seconds is preferred over g_timeout_add. \nThis internally creates a main loop source using g_timeout_source_new_seconds and attaches it to the main loop context using g_source_attach. You can do these steps manually if you need greater control. \nThe interval given is in terms of monotonic time not wall clock time. See g_get_monotonic_time. \n"});