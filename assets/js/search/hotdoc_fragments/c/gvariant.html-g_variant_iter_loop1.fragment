fragment_downloaded_cb({"url": "c/gvariant.html#g_variant_iter_loop1", "fragment": "g_variant_iter_loop \nGets the next item in the container and unpacks it into the variable argument list according to format_string returning TRUE. \nIf no more items remain then FALSE is returned. \nOn the first call to this function the pointers appearing on the variable argument list are assumed to point at uninitialised memory. On the second and later calls it is assumed that the same pointers will be given and that they will point to the memory as set by the previous call to this function. This allows the previous values to be freed as appropriate. \nThis function is intended to be used with a while loop as demonstrated in the following example. This function can only be used when iterating over an array. It is only valid to call this function with a string constant for the format string and the same string constant must be used each time. Mixing calls to this function and g_variant_iter_next or g_variant_iter_next_value on the same iterator causes undefined behavior. \nIf you break out of a such a while loop using g_variant_iter_loop then you must free or unreference all the unpacked values as you would with g_variant_get. Failure to do so will cause a memory leak. \nHere is an example for memory management with g_variant_iter_loop \nFor most cases you should use g_variant_iter_next. \nThis function is really only useful when unpacking into GVariant or GVariantIter in order to allow you to skip the call to g_variant_unref or g_variant_iter_free. \nFor example if you are only looping over simple integer and string types g_variant_iter_next is definitely preferred. For string types use the prefix to avoid allocating any memory at all and thereby avoiding the need to free anything as well \nformat_string determines the C types that are used for unpacking the values and also determines if the values are copied or borrowed. \nSee the section on GVariant format strings gvariant format strings pointers \n"});