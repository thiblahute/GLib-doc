<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>GMarkupParser</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>


</head>

<body data-spy="scroll" data-target="#toc" data-offset="70">

<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a id="home-link" class="hotdoc-navbar-brand">
				
<img src="assets/images/home.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
						<form action="" class="navbar-form navbar-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                       </form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="gi-extension" data-hotdoc-in-toplevel="True" data-hotdoc-project="GLib-2.0" data-hotdoc-ref="markup.html" class="page_container" id="page-wrapper" data-hotdoc-meta-gi-languages="c,python,javascript" data-hotdoc-meta-gi-language="c">
	<div class="row">
		
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
	<button id="offcanvasleft" class="btn btn-xs" type="button" data-toggle="offcanvasleft">
		<i class="glyphicon glyphicon-chevron-right" id="offcanvasleft-chevron"></i>
	</button>
</div>

<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="content-column">

	<div id="main">
				    <div id="page-description" data-hotdoc-source="markup.markdown">
        <h1 id="gmarkupparser">GMarkupParser</h1>
    </div>
        

            <h2 class="symbol_section" id="">GMarkupParseContext</h2>
        



            <h3 class="symbol_section" id="GMarkupParseContextConstructors">Constructors</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="g_markup_parse_context_new">
		
<h4 id="g_markup_parse_context_new1">
	<span><code>g_markup_parse_context_new</code></span>
</h4>

		

<pre class="prototype">
<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> *
g_markup_parse_context_new (const <a title="GMarkupParser" href="markup.html#GMarkupParser">GMarkupParser</a> * parser,
                            <a title="GMarkupParseFlags" href="markup.html#GMarkupParseFlags">GMarkupParseFlags</a> flags,
                            gpointer user_data,
                            <a title="GDestroyNotify" href="datasets.html#GDestroyNotify">GDestroyNotify</a> user_data_dnotify)</pre>

<p>Creates a new parse context. A parse context is used to parse
marked-up documents. You can feed any number of documents into
a context, as long as no errors occur; once an error occurs,
the parse context can't continue to parse text (you have to
free it and create a new parse context).</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>parser:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParser">GMarkupParser</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>flags:</code></em></i>
		</p>
	</td>
		<td><p>one or more <a href="markup.html#GMarkupParseFlags">GMarkupParseFlags</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>user_data:</code></em></i>
		</p>
	</td>
		<td><p>user data to pass to <a href="markup.html#GMarkupParser">GMarkupParser</a> functions</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>user_data_dnotify:</code></em></i>
		</p>
	</td>
		<td><p>user data destroy notifier called when
the parse context is freed</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a new <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>

	</td>
	<td>
		<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> *
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>




            <h3 class="symbol_section" id="GMarkupParseContextMethods">Methods</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.18;" id="g_markup_parse_context_pop">
		
<h4 id="g_markup_parse_context_pop1">
	<span><code>g_markup_parse_context_pop</code></span>
</h4>

		

<pre class="prototype">
gpointer
g_markup_parse_context_pop (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context)</pre>

<p>Completes the process of a temporary sub-parser redirection.</p>
<p>This function exists to collect the user_data allocated by a
matching call to <a href="markup.html#g_markup_parse_context_push">g_markup_parse_context_push</a>. It must be called
in the end_element handler corresponding to the start_element
handler during which <a href="markup.html#g_markup_parse_context_push">g_markup_parse_context_push</a> was called.
You must not call this function from the error callback -- the
<em>user_data</em> is provided directly to the callback in that case.</p>
<p>This function is not intended to be directly called by users
interested in invoking subparsers. Instead, it is intended to
be used by the subparsers themselves to implement a higher-level
interface.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters1">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns1">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the user data passed to <a href="markup.html#g_markup_parse_context_push">g_markup_parse_context_push</a></p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.18
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_markup_parse_context_end_parse">
		
<h4 id="g_markup_parse_context_end_parse1">
	<span><code>g_markup_parse_context_end_parse</code></span>
</h4>

		

<pre class="prototype">
gboolean
g_markup_parse_context_end_parse (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context)</pre>

<p>Signals to the <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a> that all data has been
fed into the parse context with <a href="markup.html#g_markup_parse_context_parse">g_markup_parse_context_parse</a>.</p>
<p>This function reports an error if the document isn't complete,
for example if elements are still open.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters2">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns2">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> on success, <a href="macros.html#FALSE">FALSE</a> if an error was set</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_markup_parse_context_free">
		
<h4 id="g_markup_parse_context_free1">
	<span><code>g_markup_parse_context_free</code></span>
</h4>

		

<pre class="prototype">
void
g_markup_parse_context_free (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context)</pre>

<p>Frees a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a>.</p>
<p>This function can't be called from inside one of the
<a href="markup.html#GMarkupParser">GMarkupParser</a> functions or while a subparser is pushed.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters3">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.36;" id="g_markup_parse_context_ref">
		
<h4 id="g_markup_parse_context_ref1">
	<span><code>g_markup_parse_context_ref</code></span>
</h4>

		

<pre class="prototype">
<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> *
g_markup_parse_context_ref (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context)</pre>

<p>Increases the reference count of <em>context</em>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters4">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns3">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the same <em>context</em></p>

	</td>
	<td>
		<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> *
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.36
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_markup_parse_context_get_position">
		
<h4 id="g_markup_parse_context_get_position1">
	<span><code>g_markup_parse_context_get_position</code></span>
</h4>

		

<pre class="prototype">
void
g_markup_parse_context_get_position (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context,
                                     gint* line_number,
                                     gint* char_number)</pre>

<p>Retrieves the current line number and the number of the character on
that line. Intended for use in error messages; there are no strict
semantics for what constitutes the "current" line number other than
"the best number we could come up with for error messages."</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters5">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>line_number:</code></em></i>
		</p>
	</td>
		<td><p>return location for a line number, or <a href="macros.html#NULL">NULL</a></p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>char_number:</code></em></i>
		</p>
	</td>
		<td><p>return location for a char-on-line number, or <a href="macros.html#NULL">NULL</a></p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.2;" id="g_markup_parse_context_get_element">
		
<h4 id="g_markup_parse_context_get_element1">
	<span><code>g_markup_parse_context_get_element</code></span>
</h4>

		

<pre class="prototype">
const gchar*
g_markup_parse_context_get_element (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context)</pre>

<p>Retrieves the name of the currently open element.</p>
<p>If called from the start_element or end_element handlers this will
give the element_name as passed to those functions. For the parent
elements, see <a href="markup.html#g_markup_parse_context_get_element_stack">g_markup_parse_context_get_element_stack</a>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters6">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns4">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the name of the currently open element, or <a href="macros.html#NULL">NULL</a></p>

	</td>
	<td>
		const gchar*
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.2
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.36;" id="g_markup_parse_context_unref">
		
<h4 id="g_markup_parse_context_unref1">
	<span><code>g_markup_parse_context_unref</code></span>
</h4>

		

<pre class="prototype">
void
g_markup_parse_context_unref (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context)</pre>

<p>Decreases the reference count of <em>context</em>.  When its reference count
drops to 0, it is freed.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters7">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.36
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_markup_parse_context_parse">
		
<h4 id="g_markup_parse_context_parse1">
	<span><code>g_markup_parse_context_parse</code></span>
</h4>

		

<pre class="prototype">
gboolean
g_markup_parse_context_parse (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context,
                              const gchar* text,
                              gssize text_len)</pre>

<p>Feed some data to the <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a>.</p>
<p>The data need not be valid UTF-8; an error will be signaled if
it's invalid. The data need not be an entire document; you can
feed a document into the parser incrementally, via multiple calls
to this function. Typically, as you receive data from a network
connection or file, you feed each received chunk of data into this
function, aborting the process if an error occurs. Once an error
is reported, no further data may be fed to the <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a>;
all errors are fatal.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters8">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>text:</code></em></i>
		</p>
	</td>
		<td><p>chunk of text to parse</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>text_len:</code></em></i>
		</p>
	</td>
		<td><p>length of <em>text</em> in bytes</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns5">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#FALSE">FALSE</a> if an error occurred, <a href="macros.html#TRUE">TRUE</a> on success</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.16;" id="g_markup_parse_context_get_element_stack">
		
<h4 id="g_markup_parse_context_get_element_stack1">
	<span><code>g_markup_parse_context_get_element_stack</code></span>
</h4>

		

<pre class="prototype">
const <a title="GSList" href="linked_lists_single.html#GSList">GSList</a> *
g_markup_parse_context_get_element_stack (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context)</pre>

<p>Retrieves the element stack from the internal state of the parser.</p>
<p>The returned <a href="linked_lists_single.html#GSList">GSList</a> is a list of strings where the first item is
the currently open tag (as would be returned by
<a href="markup.html#g_markup_parse_context_get_element">g_markup_parse_context_get_element</a>) and the next item is its
immediate parent.</p>
<p>This function is intended to be used in the start_element and
end_element handlers where <a href="markup.html#g_markup_parse_context_get_element">g_markup_parse_context_get_element</a>
would merely return the name of the element that is being
processed.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters9">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns6">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the element stack, which must not be modified</p>

	</td>
	<td>
		const <a title="GSList" href="linked_lists_single.html#GSList">GSList</a> *
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.16
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.18;" id="g_markup_parse_context_get_user_data">
		
<h4 id="g_markup_parse_context_get_user_data1">
	<span><code>g_markup_parse_context_get_user_data</code></span>
</h4>

		

<pre class="prototype">
gpointer
g_markup_parse_context_get_user_data (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context)</pre>

<p>Returns the user_data associated with <em>context</em>.</p>
<p>This will either be the user_data that was provided to
<a href="markup.html#g_markup_parse_context_new">g_markup_parse_context_new</a> or to the most recent call
of <a href="markup.html#g_markup_parse_context_push">g_markup_parse_context_push</a>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters10">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns7">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the provided user_data. The returned data belongs to
the markup context and will be freed when
<a href="markup.html#g_markup_parse_context_free">g_markup_parse_context_free</a> is called.</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.18
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.18;" id="g_markup_parse_context_push">
		
<h4 id="g_markup_parse_context_push1">
	<span><code>g_markup_parse_context_push</code></span>
</h4>

		

<pre class="prototype">
void
g_markup_parse_context_push (<a title="GMarkupParseContext" href="markup.html#GMarkupParseContext">GMarkupParseContext</a> * context,
                             const <a title="GMarkupParser" href="markup.html#GMarkupParser">GMarkupParser</a> * parser,
                             gpointer user_data)</pre>

<p>Temporarily redirects markup data to a sub-parser.</p>
<p>This function may only be called from the start_element handler of
a <a href="markup.html#GMarkupParser">GMarkupParser</a>. It must be matched with a corresponding call to
<a href="markup.html#g_markup_parse_context_pop">g_markup_parse_context_pop</a> in the matching end_element handler
(except in the case that the parser aborts due to an error).</p>
<p>All tags, text and other data between the matching tags is
redirected to the subparser given by <em>parser</em>. <em>user_data</em> is used
as the user_data for that parser. <em>user_data</em> is also passed to the
error callback in the event that an error occurs. This includes
errors that occur in subparsers of the subparser.</p>
<p>The end tag matching the start tag for which this call was made is
handled by the previous parser (which is given its own user_data)
which is why <a href="markup.html#g_markup_parse_context_pop">g_markup_parse_context_pop</a> is provided to allow "one
last access" to the <em>user_data</em> provided to this function. In the
case of error, the <em>user_data</em> provided here is passed directly to
the error callback of the subparser and <a href="markup.html#g_markup_parse_context_pop">g_markup_parse_context_pop</a>
should not be called. In either case, if <em>user_data</em> was allocated
then it ought to be freed from both of these locations.</p>
<p>This function is not intended to be directly called by users
interested in invoking subparsers. Instead, it is intended to be
used by the subparsers themselves to implement a higher-level
interface.</p>
<p>As an example, see the following implementation of a simple
parser that counts the number of tags encountered.</p>
<pre><code class="language-[&lt;!--"> typedef struct
 {
   gint tag_count;
 } CounterData;

 static void
 counter_start_element (GMarkupParseContext  *context,
                        const gchar          *element_name,
                        const gchar         **attribute_names,
                        const gchar         **attribute_values,
                        gpointer              user_data,
                        GError              **error)
 {
   CounterData *data = user_data;

   data-&gt;tag_count++;
 }

 static void
 counter_error (GMarkupParseContext *context,
                GError              *error,
                gpointer             user_data)
 {
   CounterData *data = user_data;

   g_slice_free (CounterData, data);
 }

 static GMarkupParser counter_subparser =
 {
   counter_start_element,
   NULL,
   NULL,
   NULL,
   counter_error
 };
</code></pre>
<p>In order to allow this parser to be easily used as a subparser, the
following interface is provided:</p>
<pre><code class="language-[&lt;!--"> void
 start_counting (GMarkupParseContext *context)
 {
   CounterData *data = g_slice_new (CounterData);

   data-&gt;tag_count = 0;
   g_markup_parse_context_push (context, &amp;counter_subparser, data);
 }

 gint
 end_counting (GMarkupParseContext *context)
 {
   CounterData *data = g_markup_parse_context_pop (context);
   int result;

   result = data-&gt;tag_count;
   g_slice_free (CounterData, data);

   return result;
 }
</code></pre>
<p>The subparser would then be used as follows:</p>
<pre><code class="language-[&lt;!--"> static void start_element (context, element_name, ...)
 {
   if (strcmp (element_name, "count-these") == 0)
     start_counting (context);

   // else, handle other tags...
 }

 static void end_element (context, element_name, ...)
 {
   if (strcmp (element_name, "count-these") == 0)
     g_print ("Counted %d tags\n", end_counting (context));

   // else, handle other tags...
 }
</code></pre>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters11">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>context:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParseContext">GMarkupParseContext</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>parser:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="markup.html#GMarkupParser">GMarkupParser</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>user_data:</code></em></i>
		</p>
	</td>
		<td><p>user data to pass to <a href="markup.html#GMarkupParser">GMarkupParser</a> functions</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.18
		</p>

</div>



        



            <h2 class="symbol_section" id="Functions">Functions</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="g_markup_error_quark">
		
<h3 id="g_markup_error_quark1">
	<span><code>g_markup_error_quark</code></span>
</h3>

		

<pre class="prototype">
<a title="GQuark" href="quarks.html#GQuark">GQuark</a>
g_markup_error_quark ()</pre>



	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns8">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		<a title="GQuark" href="quarks.html#GQuark">GQuark</a>
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_markup_vprintf_escaped">
		
<h3 id="g_markup_vprintf_escaped1">
	<span><code>g_markup_vprintf_escaped</code></span>
</h3>

		

<pre class="prototype">
gchar*
g_markup_vprintf_escaped (const char* format,
                          va_list args)</pre>

<p>Formats the data in <em>args</em> according to <em>format</em>, escaping
all string and character arguments in the fashion
of <a href="markup.html#g_markup_escape_text">g_markup_escape_text</a>. See <a href="markup.html#g_markup_printf_escaped">g_markup_printf_escaped</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters12">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>format:</code></em></i>
		</p>
	</td>
		<td><p>printf style format string</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>args:</code></em></i>
		</p>
	</td>
		<td><p>variable argument list, similar to vprintf</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns9">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>newly allocated result from formatting
operation. Free with <a href="memory.html#g_free">g_free</a>.</p>

	</td>
	<td>
		gchar*
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_markup_printf_escaped">
		
<h3 id="g_markup_printf_escaped1">
	<span><code>g_markup_printf_escaped</code></span>
</h3>

		

<pre class="prototype">
gchar*
g_markup_printf_escaped (const char* format,
                         ... ...)</pre>

<p>Formats arguments according to <em>format</em>, escaping
all string and character arguments in the fashion
of <a href="markup.html#g_markup_escape_text">g_markup_escape_text</a>. This is useful when you
want to insert literal strings into XML-style markup
output, without having to worry that the strings
might themselves contain markup.</p>
<pre><code class="language-[&lt;!--"> const char *store = "Fortnum &amp; Mason";
 const char *item = "Tea";
 char *output;

 output = g_markup_printf_escaped ("&lt;purchase&gt;"
                                   "&lt;store&gt;%s&lt;/store&gt;"
                                   "&lt;item&gt;%s&lt;/item&gt;"
                                   "&lt;/purchase&gt;",
                                   store, item);
</code></pre>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters13">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>format:</code></em></i>
		</p>
	</td>
		<td><p>printf style format string</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>...:</code></em></i>
		</p>
	</td>
		<td><p>the arguments to insert in the format string</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns10">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>newly allocated result from formatting
operation. Free with <a href="memory.html#g_free">g_free</a>.</p>

	</td>
	<td>
		gchar*
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.16;" id="g_markup_collect_attributes">
		
<h3 id="g_markup_collect_attributes1">
	<span><code>g_markup_collect_attributes</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_markup_collect_attributes (const gchar* element_name,
                             const gchar** attribute_names,
                             const gchar** attribute_values,
                             <a title="GError" href="error_reporting.html#GError">GError</a> ** error,
                             <a title="GMarkupCollectType" href="markup.html#GMarkupCollectType">GMarkupCollectType</a> first_type,
                             const gchar* first_attr,
                             ... ...)</pre>

<p>Collects the attributes of the element from the data passed to the
<a href="markup.html#GMarkupParser">GMarkupParser</a> start_element function, dealing with common error
conditions and supporting boolean values.</p>
<p>This utility function is not required to write a parser but can save
a lot of typing.</p>
<p>The <em>element_name</em>, <em>attribute_names</em>, <em>attribute_values</em> and <em>error</em>
parameters passed to the start_element callback should be passed
unmodified to this function.</p>
<p>Following these arguments is a list of "supported" attributes to collect.
It is an error to specify multiple attributes with the same name. If any
attribute not in the list appears in the <em>attribute_names</em> array then an
unknown attribute error will result.</p>
<p>The <a href="markup.html#GMarkupCollectType">GMarkupCollectType</a> field allows specifying the type of collection
to perform and if a given attribute must appear or is optional.</p>
<p>The attribute name is simply the name of the attribute to collect.</p>
<p>The pointer should be of the appropriate type (see the descriptions
under <a href="markup.html#GMarkupCollectType">GMarkupCollectType</a>) and may be <a href="macros.html#NULL">NULL</a> in case a particular
attribute is to be allowed but ignored.</p>
<p>This function deals with issuing errors for missing attributes
(of type <a href="markup.html#G_MARKUP_ERROR_MISSING_ATTRIBUTE">G_MARKUP_ERROR_MISSING_ATTRIBUTE</a>), unknown attributes
(of type <a href="markup.html#G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE">G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE</a>) and duplicate
attributes (of type <a href="markup.html#G_MARKUP_ERROR_INVALID_CONTENT">G_MARKUP_ERROR_INVALID_CONTENT</a>) as well
as parse errors for boolean-valued attributes (again of type
<a href="markup.html#G_MARKUP_ERROR_INVALID_CONTENT">G_MARKUP_ERROR_INVALID_CONTENT</a>). In all of these cases <a href="macros.html#FALSE">FALSE</a>
will be returned and <em>error</em> will be set as appropriate.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters14">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>element_name:</code></em></i>
		</p>
	</td>
		<td><p>the current tag name</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>attribute_names:</code></em></i>
		</p>
	</td>
		<td><p>the attribute names</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>attribute_values:</code></em></i>
		</p>
	</td>
		<td><p>the attribute values</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>error:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a <a href="error_reporting.html#GError">GError</a> or <a href="macros.html#NULL">NULL</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>first_type:</code></em></i>
		</p>
	</td>
		<td><p>the <a href="markup.html#GMarkupCollectType">GMarkupCollectType</a> of the first attribute</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>first_attr:</code></em></i>
		</p>
	</td>
		<td><p>the name of the first attribute</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>...:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to the storage location of the first attribute
(or <a href="macros.html#NULL">NULL</a>), followed by more types names and pointers, ending
with <a href="markup.html#G_MARKUP_COLLECT_INVALID">G_MARKUP_COLLECT_INVALID</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns11">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if successful</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.16
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_markup_escape_text">
		
<h3 id="g_markup_escape_text1">
	<span><code>g_markup_escape_text</code></span>
</h3>

		

<pre class="prototype">
gchar*
g_markup_escape_text (const gchar* text,
                      gssize length)</pre>

<p>Escapes text so that the markup parser will parse it verbatim.
Less than, greater than, ampersand, etc. are replaced with the
corresponding entities. This function would typically be used
when writing out a file to be parsed with the markup parser.</p>
<p>Note that this function doesn't protect whitespace and line endings
from being processed according to the XML rules for normalization
of line endings and attribute values.</p>
<p>Note also that this function will produce character references in
the range of  ...  for all control sequences
except for tabstop, newline and carriage return.  The character
references in this range are not valid XML 1.0, but they are
valid XML 1.1 and will be accepted by the GMarkup parser.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters15">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>text:</code></em></i>
		</p>
	</td>
		<td><p>some valid UTF-8 text</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>length:</code></em></i>
		</p>
	</td>
		<td><p>length of <em>text</em> in bytes, or -1 if the text is nul-terminated</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns12">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a newly allocated string with the escaped text</p>

	</td>
	<td>
		gchar*
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>




            <h2 class="symbol_section" id="Structures">Structures</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="GMarkupParser">
		
<h3 id="struct-gmarkupparser">
		struct GMarkupParser
	</h3>

		<pre class="raw_code">
struct GMarkupParser {
    void start_element (GMarkupParseContext* context, const gchar* element_name, const gchar** attribute_names, const gchar** attribute_values, gpointer user_data);
    void end_element (GMarkupParseContext* context, const gchar* element_name, gpointer user_data);
    void text (GMarkupParseContext* context, const gchar* text, gsize text_len, gpointer user_data);
    void passthrough (GMarkupParseContext* context, const gchar* passthrough_text, gsize text_len, gpointer user_data);
    void error (GMarkupParseContext* context, GError* error, gpointer user_data);
};
</pre>

<p>Any of the fields in <a href="markup.html#GMarkupParser">GMarkupParser</a> can be <a href="macros.html#NULL">NULL</a>, in which case they
will be ignored. Except for the <em>error</em> function, any of these callbacks
can set an error; in particular the <a href="markup.html#G_MARKUP_ERROR_UNKNOWN_ELEMENT">G_MARKUP_ERROR_UNKNOWN_ELEMENT</a>,
<a href="markup.html#G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE">G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE</a>, and <a href="markup.html#G_MARKUP_ERROR_INVALID_CONTENT">G_MARKUP_ERROR_INVALID_CONTENT</a>
errors are intended to be set from these callbacks. If you set an error
from a callback, <a href="markup.html#g_markup_parse_context_parse">g_markup_parse_context_parse</a> will report that error
back to its caller.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="fields">Fields</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr id="GMarkupParser.start_element()">
		<td>
		<p>
		<i><em><code>void <em><code>start_element()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMarkupParser.end_element()">
		<td>
		<p>
		<i><em><code>void <em><code>end_element()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMarkupParser.text()">
		<td>
		<p>
		<i><em><code>void <em><code>text()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMarkupParser.passthrough()">
		<td>
		<p>
		<i><em><code>void <em><code>passthrough()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMarkupParser.error()">
		<td>
		<p>
		<i><em><code>void <em><code>error()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="GMarkupParseContext">
		
<h3 id="struct-gmarkupparsecontext">
		struct GMarkupParseContext
	</h3>

		<pre class="raw_code">
struct GMarkupParseContext {
};
</pre>

<p>A parse context is used to parse a stream of bytes that
you expect to contain marked-up text.</p>
<p>See <a href="markup.html#g_markup_parse_context_new">g_markup_parse_context_new</a>, <a href="markup.html#GMarkupParser">GMarkupParser</a>, and so
on for more details.</p>




</div>




            <h2 class="symbol_section" id="Enumerations">Enumerations</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="GMarkupCollectType">
		
<h3 id="enum-gmarkupcollecttype">
		enum GMarkupCollectType
	</h3>

		<p>A mixed enumerated type and flags field. You must specify one type
(string, strdup, boolean, tristate).  Additionally, you may  optionally
bitwise OR the type with the flag <a href="markup.html#G_MARKUP_COLLECT_OPTIONAL">G_MARKUP_COLLECT_OPTIONAL</a>.</p>
<p>It is likely that this enum will be extended in the future to
support other types.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="members">Members</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr>
	<td>
		<p>
		<a id="G_MARKUP_COLLECT_INVALID"></a>
		G_MARKUP_COLLECT_INVALID
		</p>
	</td>
	<td><p>used to terminate the list of attributes
to collect</p>
</td>
	<td>
		<span class="value">Value: 0</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_COLLECT_STRING"></a>
		G_MARKUP_COLLECT_STRING
		</p>
	</td>
	<td><p>collect the string pointer directly from
the attribute_values[] array. Expects a parameter of type (const
char **). If <a href="markup.html#G_MARKUP_COLLECT_OPTIONAL">G_MARKUP_COLLECT_OPTIONAL</a> is specified and the
attribute isn't present then the pointer will be set to <a href="macros.html#NULL">NULL</a></p>
</td>
	<td>
		<span class="value">Value: 1</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_COLLECT_STRDUP"></a>
		G_MARKUP_COLLECT_STRDUP
		</p>
	</td>
	<td><p>as with <a href="markup.html#G_MARKUP_COLLECT_STRING">G_MARKUP_COLLECT_STRING</a>, but
expects a parameter of type (char **) and <a href="string_utils.html#g_strdup">g_strdup</a>s the
returned pointer. The pointer must be freed with <a href="memory.html#g_free">g_free</a></p>
</td>
	<td>
		<span class="value">Value: 2</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_COLLECT_BOOLEAN"></a>
		G_MARKUP_COLLECT_BOOLEAN
		</p>
	</td>
	<td><p>expects a parameter of type (gboolean *)
and parses the attribute value as a boolean. Sets <a href="macros.html#FALSE">FALSE</a> if the
attribute isn't present. Valid boolean values consist of
(case-insensitive) "false", "f", "no", "n", "0" and "true", "t",
"yes", "y", "1"</p>
</td>
	<td>
		<span class="value">Value: 3</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_COLLECT_TRISTATE"></a>
		G_MARKUP_COLLECT_TRISTATE
		</p>
	</td>
	<td><p>as with <a href="markup.html#G_MARKUP_COLLECT_BOOLEAN">G_MARKUP_COLLECT_BOOLEAN</a>, but
in the case of a missing attribute a value is set that compares
equal to neither <a href="macros.html#FALSE">FALSE</a> nor <a href="macros.html#TRUE">TRUE</a> G_MARKUP_COLLECT_OPTIONAL is
implied</p>
</td>
	<td>
		<span class="value">Value: 4</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_COLLECT_OPTIONAL"></a>
		G_MARKUP_COLLECT_OPTIONAL
		</p>
	</td>
	<td><p>can be bitwise ORed with the other fields.
If present, allows the attribute not to appear. A default value
is set depending on what value type is used</p>
</td>
	<td>
		<span class="value">Value: 65536</span>
	</td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="GMarkupError">
		
<h3 id="enum-gmarkuperror">
		enum GMarkupError
	</h3>

		<p>Error codes returned by markup parsing.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="members1">Members</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr>
	<td>
		<p>
		<a id="G_MARKUP_ERROR_BAD_UTF8"></a>
		G_MARKUP_ERROR_BAD_UTF8
		</p>
	</td>
	<td><p>text being parsed was not valid UTF-8</p>
</td>
	<td>
		<span class="value">Value: 0</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_ERROR_EMPTY"></a>
		G_MARKUP_ERROR_EMPTY
		</p>
	</td>
	<td><p>document contained nothing, or only whitespace</p>
</td>
	<td>
		<span class="value">Value: 1</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_ERROR_PARSE"></a>
		G_MARKUP_ERROR_PARSE
		</p>
	</td>
	<td><p>document was ill-formed</p>
</td>
	<td>
		<span class="value">Value: 2</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_ERROR_UNKNOWN_ELEMENT"></a>
		G_MARKUP_ERROR_UNKNOWN_ELEMENT
		</p>
	</td>
	<td><p>error should be set by <a href="markup.html#GMarkupParser">GMarkupParser</a>
functions; element wasn't known</p>
</td>
	<td>
		<span class="value">Value: 3</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE"></a>
		G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE
		</p>
	</td>
	<td><p>error should be set by <a href="markup.html#GMarkupParser">GMarkupParser</a>
functions; attribute wasn't known</p>
</td>
	<td>
		<span class="value">Value: 4</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_ERROR_INVALID_CONTENT"></a>
		G_MARKUP_ERROR_INVALID_CONTENT
		</p>
	</td>
	<td><p>error should be set by <a href="markup.html#GMarkupParser">GMarkupParser</a>
functions; content was invalid</p>
</td>
	<td>
		<span class="value">Value: 5</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_ERROR_MISSING_ATTRIBUTE"></a>
		G_MARKUP_ERROR_MISSING_ATTRIBUTE
		</p>
	</td>
	<td><p>error should be set by <a href="markup.html#GMarkupParser">GMarkupParser</a>
functions; a required attribute was missing</p>
</td>
	<td>
		<span class="value">Value: 6</span>
	</td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="GMarkupParseFlags">
		
<h3 id="enum-gmarkupparseflags">
		enum GMarkupParseFlags
	</h3>

		<p>Flags that affect the behaviour of the parser.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="members2">Members</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr>
	<td>
		<p>
		<a id="G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG"></a>
		G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG
		</p>
	</td>
	<td><p>flag you should not use</p>
</td>
	<td>
		<span class="value">Value: 1</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_TREAT_CDATA_AS_TEXT"></a>
		G_MARKUP_TREAT_CDATA_AS_TEXT
		</p>
	</td>
	<td><p>When this flag is set, CDATA marked
sections are not passed literally to the <em>passthrough</em> function of
the parser. Instead, the content of the section (without the
<code>&lt;![CDATA[</code> and <code>]]&gt;</code>) is
passed to the <em>text</em> function. This flag was added in GLib 2.12</p>
</td>
	<td>
		<span class="value">Value: 2</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_PREFIX_ERROR_POSITION"></a>
		G_MARKUP_PREFIX_ERROR_POSITION
		</p>
	</td>
	<td><p>Normally errors caught by GMarkup
itself have line/column information prefixed to them to let the
caller know the location of the error. When this flag is set the
location information is also prefixed to errors generated by the
<a href="markup.html#GMarkupParser">GMarkupParser</a> implementation functions</p>
</td>
	<td>
		<span class="value">Value: 4</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_MARKUP_IGNORE_QUALIFIED"></a>
		G_MARKUP_IGNORE_QUALIFIED
		</p>
	</td>
	<td><p>Ignore (don't report) qualified
attributes and tags, along with their contents.  A qualified
attribute or tag is one that contains ':' in its name (ie: is in
another namespace).  Since: 2.40.</p>
</td>
	<td>
		<span class="value">Value: 8</span>
	</td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>




            <h2 class="symbol_section" id="Constants">Constants</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="G_MARKUP_ERROR">
		
<h3 class="constant" id="g_markup_error">
	G_MARKUP_ERROR
</h3>

		<pre class="raw_code">
#define G_MARKUP_ERROR g_markup_error_quark ()
</pre>

<p>Error domain for markup parsing.
Errors in this domain will be from the <a href="markup.html#GMarkupError">GMarkupError</a> enumeration.
See <a href="error_reporting.html#GError">GError</a> for information on error domains.</p>


</div>






		<div id="subpages"></div>
		</div>
		<div id="search_results">
			<p>The results of the search are</p>
		</div>
	</div>

</div>

<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2">
	<div id="toc-column">
		
					<div class="edit-button">
				

			</div>
				<div id="toc-wrapper">
			<nav id="toc"></nav>
		</div>
	</div>
</div>
	</div>

</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-lg-3 col-xl-2" id="footer-left-column"></div>
		<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="footer-content-column">
						    

		</div>
		<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2" id="footer-right-column"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>