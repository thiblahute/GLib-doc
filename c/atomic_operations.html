<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>atomic_operations</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>


</head>

<body data-spy="scroll" data-target="#toc" data-offset="70">

<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a id="home-link" class="hotdoc-navbar-brand">
				
<img src="assets/images/home.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
						<form action="" class="navbar-form navbar-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                       </form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="gi-extension" data-hotdoc-in-toplevel="True" data-hotdoc-project="GLib-2.0" data-hotdoc-ref="atomic_operations.html" class="page_container" id="page-wrapper" data-hotdoc-meta-gi-languages="c,python,javascript" data-hotdoc-meta-gi-language="c">
	<div class="row">
		
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
	<button id="offcanvasleft" class="btn btn-xs" type="button" data-toggle="offcanvasleft">
		<i class="glyphicon glyphicon-chevron-right" id="offcanvasleft-chevron"></i>
	</button>
</div>

<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="content-column">

	<div id="main">
				    <div id="page-description" data-hotdoc-source="atomic_operations.markdown">
    </div>
        

        



            <h2 class="symbol_section" id="Functions">Functions</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_atomic_pointer_add">
		
<h3 id="g_atomic_pointer_add1">
	<span><code>g_atomic_pointer_add</code></span>
</h3>

		

<pre class="prototype">
gssize
g_atomic_pointer_add (void* atomic,
                      gssize val)</pre>

<p>Atomically adds <em>val</em> to the value of <em>atomic</em>.</p>
<p>Think of this operation as an atomic version of
<code>{ tmp = *atomic; *atomic += val; return tmp; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to add</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the add, signed</p>

	</td>
	<td>
		gssize
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_int_dec_and_test">
		
<h3 id="g_atomic_int_dec_and_test1">
	<span><code>g_atomic_int_dec_and_test</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_atomic_int_dec_and_test (volatile gint* atomic)</pre>

<p>Decrements the value of <em>atomic</em> by 1.</p>
<p>Think of this operation as an atomic version of
<code>{ *atomic -= 1; return (*atomic == 0); }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters1">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns1">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if the resultant value is zero</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_int_set">
		
<h3 id="g_atomic_int_set1">
	<span><code>g_atomic_int_set</code></span>
</h3>

		

<pre class="prototype">
void
g_atomic_int_set (volatile gint* atomic,
                  gint newval)</pre>

<p>Sets the value of <em>atomic</em> to <em>newval</em>.</p>
<p>This call acts as a full compiler and hardware
memory barrier (after the set).</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters2">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>newval:</code></em></i>
		</p>
	</td>
		<td><p>a new value to store</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_pointer_compare_and_exchange">
		
<h3 id="g_atomic_pointer_compare_and_exchange1">
	<span><code>g_atomic_pointer_compare_and_exchange</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_atomic_pointer_compare_and_exchange (void* atomic,
                                       gpointer oldval,
                                       gpointer newval)</pre>

<p>Compares <em>atomic</em> to <em>oldval</em> and, if equal, sets it to <em>newval</em>.
If <em>atomic</em> was not equal to <em>oldval</em> then no change occurs.</p>
<p>This compare and exchange is done atomically.</p>
<p>Think of this operation as an atomic version of
<code>{ if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters3">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>oldval:</code></em></i>
		</p>
	</td>
		<td><p>the value to compare with</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>newval:</code></em></i>
		</p>
	</td>
		<td><p>the value to conditionally replace with</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns2">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if the exchange took place</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_atomic_int_or">
		
<h3 id="g_atomic_int_or1">
	<span><code>g_atomic_int_or</code></span>
</h3>

		

<pre class="prototype">
guint
g_atomic_int_or (volatile guint* atomic,
                 guint val)</pre>

<p>Performs an atomic bitwise 'or' of the value of <em>atomic</em> and <em>val</em>,
storing the result back in <em>atomic</em>.</p>
<p>Think of this operation as an atomic version of
<code>{ tmp = *atomic; *atomic |= val; return tmp; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters4">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to 'or'</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns3">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the operation, unsigned</p>

	</td>
	<td>
		guint
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_int_inc">
		
<h3 id="g_atomic_int_inc1">
	<span><code>g_atomic_int_inc</code></span>
</h3>

		

<pre class="prototype">
void
g_atomic_int_inc (volatile gint* atomic)</pre>

<p>Increments the value of <em>atomic</em> by 1.</p>
<p>Think of this operation as an atomic version of <code>{ *atomic += 1; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters5">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_atomic_int_and">
		
<h3 id="g_atomic_int_and1">
	<span><code>g_atomic_int_and</code></span>
</h3>

		

<pre class="prototype">
guint
g_atomic_int_and (volatile guint* atomic,
                  guint val)</pre>

<p>Performs an atomic bitwise 'and' of the value of <em>atomic</em> and <em>val</em>,
storing the result back in <em>atomic</em>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>
<p>Think of this operation as an atomic version of
<code>{ tmp = *atomic; *atomic &amp;= val; return tmp; }</code>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters6">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to 'and'</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns4">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the operation, unsigned</p>

	</td>
	<td>
		guint
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_pointer_get">
		
<h3 id="g_atomic_pointer_get1">
	<span><code>g_atomic_pointer_get</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_atomic_pointer_get (void* atomic)</pre>

<p>Gets the current value of <em>atomic</em>.</p>
<p>This call acts as a full compiler and hardware
memory barrier (before the get).</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters7">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns5">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of the pointer</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;deprecated:2.30;" id="g_atomic_int_exchange_and_add">
		
<h3 id="g_atomic_int_exchange_and_add1">
	<span><code>g_atomic_int_exchange_and_add</code></span>
</h3>

		

<pre class="prototype">
gint
g_atomic_int_exchange_and_add (volatile gint* atomic,
                               gint val)</pre>

<p>This function existed before <a href="atomic_operations.html#g_atomic_int_add">g_atomic_int_add</a> returned the prior
value of the integer (which it now does).  It is retained only for
compatibility reasons.  Don't use this function in new code.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters8">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to add</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns6">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the add, signed</p>

	</td>
	<td>
		gint
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>
	<p>
	deprecated			: 2.30: Use g_atomic_int_add() instead.
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_int_add">
		
<h3 id="g_atomic_int_add1">
	<span><code>g_atomic_int_add</code></span>
</h3>

		

<pre class="prototype">
gint
g_atomic_int_add (volatile gint* atomic,
                  gint val)</pre>

<p>Atomically adds <em>val</em> to the value of <em>atomic</em>.</p>
<p>Think of this operation as an atomic version of
<code>{ tmp = *atomic; *atomic += val; return tmp; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>
<p>Before version 2.30, this function did not return a value
(but <a href="atomic_operations.html#g_atomic_int_exchange_and_add">g_atomic_int_exchange_and_add</a> did, and had the same meaning).</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters9">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to add</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns7">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the add, signed</p>

	</td>
	<td>
		gint
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_int_compare_and_exchange">
		
<h3 id="g_atomic_int_compare_and_exchange1">
	<span><code>g_atomic_int_compare_and_exchange</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_atomic_int_compare_and_exchange (volatile gint* atomic,
                                   gint oldval,
                                   gint newval)</pre>

<p>Compares <em>atomic</em> to <em>oldval</em> and, if equal, sets it to <em>newval</em>.
If <em>atomic</em> was not equal to <em>oldval</em> then no change occurs.</p>
<p>This compare and exchange is done atomically.</p>
<p>Think of this operation as an atomic version of
<code>{ if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters10">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>oldval:</code></em></i>
		</p>
	</td>
		<td><p>the value to compare with</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>newval:</code></em></i>
		</p>
	</td>
		<td><p>the value to conditionally replace with</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns8">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if the exchange took place</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_int_get">
		
<h3 id="g_atomic_int_get1">
	<span><code>g_atomic_int_get</code></span>
</h3>

		

<pre class="prototype">
gint
g_atomic_int_get (volatile const gint* atomic)</pre>

<p>Gets the current value of <em>atomic</em>.</p>
<p>This call acts as a full compiler and hardware
memory barrier (before the get).</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters11">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns9">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of the integer</p>

	</td>
	<td>
		gint
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_atomic_int_xor">
		
<h3 id="g_atomic_int_xor1">
	<span><code>g_atomic_int_xor</code></span>
</h3>

		

<pre class="prototype">
guint
g_atomic_int_xor (volatile guint* atomic,
                  guint val)</pre>

<p>Performs an atomic bitwise 'xor' of the value of <em>atomic</em> and <em>val</em>,
storing the result back in <em>atomic</em>.</p>
<p>Think of this operation as an atomic version of
<code>{ tmp = *atomic; *atomic ^= val; return tmp; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters12">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gint or guint</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to 'xor'</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns10">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the operation, unsigned</p>

	</td>
	<td>
		guint
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_atomic_pointer_or">
		
<h3 id="g_atomic_pointer_or1">
	<span><code>g_atomic_pointer_or</code></span>
</h3>

		

<pre class="prototype">
gsize
g_atomic_pointer_or (void* atomic,
                     gsize val)</pre>

<p>Performs an atomic bitwise 'or' of the value of <em>atomic</em> and <em>val</em>,
storing the result back in <em>atomic</em>.</p>
<p>Think of this operation as an atomic version of
<code>{ tmp = *atomic; *atomic |= val; return tmp; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters13">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to 'or'</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns11">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the operation, unsigned</p>

	</td>
	<td>
		gsize
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_atomic_pointer_xor">
		
<h3 id="g_atomic_pointer_xor1">
	<span><code>g_atomic_pointer_xor</code></span>
</h3>

		

<pre class="prototype">
gsize
g_atomic_pointer_xor (void* atomic,
                      gsize val)</pre>

<p>Performs an atomic bitwise 'xor' of the value of <em>atomic</em> and <em>val</em>,
storing the result back in <em>atomic</em>.</p>
<p>Think of this operation as an atomic version of
<code>{ tmp = *atomic; *atomic ^= val; return tmp; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters14">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to 'xor'</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns12">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the operation, unsigned</p>

	</td>
	<td>
		gsize
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_atomic_pointer_set">
		
<h3 id="g_atomic_pointer_set1">
	<span><code>g_atomic_pointer_set</code></span>
</h3>

		

<pre class="prototype">
void
g_atomic_pointer_set (void* atomic,
                      gpointer newval)</pre>

<p>Sets the value of <em>atomic</em> to <em>newval</em>.</p>
<p>This call acts as a full compiler and hardware
memory barrier (after the set).</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters15">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>newval:</code></em></i>
		</p>
	</td>
		<td><p>a new value to store</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.4
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_atomic_pointer_and">
		
<h3 id="g_atomic_pointer_and1">
	<span><code>g_atomic_pointer_and</code></span>
</h3>

		

<pre class="prototype">
gsize
g_atomic_pointer_and (void* atomic,
                      gsize val)</pre>

<p>Performs an atomic bitwise 'and' of the value of <em>atomic</em> and <em>val</em>,
storing the result back in <em>atomic</em>.</p>
<p>Think of this operation as an atomic version of
<code>{ tmp = *atomic; *atomic &amp;= val; return tmp; }</code>.</p>
<p>This call acts as a full compiler and hardware memory barrier.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters16">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>atomic:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>val:</code></em></i>
		</p>
	</td>
		<td><p>the value to 'and'</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns13">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the value of <em>atomic</em> before the operation, unsigned</p>

	</td>
	<td>
		gsize
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.30
		</p>

</div>




            <h2 class="symbol_section" id="Constants">Constants</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="G_ATOMIC_LOCK_FREE">
		
<h3 class="constant" id="g_atomic_lock_free">
	G_ATOMIC_LOCK_FREE
</h3>

		<pre class="raw_code">
#define G_ATOMIC_LOCK_FREE
</pre>

<p>This macro is defined if the atomic operations of GLib are
implemented using real hardware atomic operations.  This means that
the GLib atomic API can be used between processes and safely mixed
with other (hardware) atomic APIs.</p>
<p>If this macro is not defined, the atomic operations may be
emulated using a mutex.  In that case, the GLib atomic operations are
only atomic relative to themselves and within a single process.</p>


</div>






		<div id="subpages"></div>
		</div>
		<div id="search_results">
			<p>The results of the search are</p>
		</div>
	</div>

</div>

<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2">
	<div id="toc-column">
		
					<div class="edit-button">
				

			</div>
				<div id="toc-wrapper">
			<nav id="toc"></nav>
		</div>
	</div>
</div>
	</div>

</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-lg-3 col-xl-2" id="footer-left-column"></div>
		<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="footer-content-column">
						    

		</div>
		<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2" id="footer-right-column"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>