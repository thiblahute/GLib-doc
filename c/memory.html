<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>GMemVTable</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>


</head>

<body data-spy="scroll" data-target="#toc" data-offset="70">

<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a id="home-link" class="hotdoc-navbar-brand">
				
<img src="assets/images/home.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
						<form action="" class="navbar-form navbar-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                       </form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="gi-extension" data-hotdoc-in-toplevel="True" data-hotdoc-project="GLib-2.0" data-hotdoc-ref="memory.html" class="page_container" id="page-wrapper" data-hotdoc-meta-gi-languages="c,python,javascript" data-hotdoc-meta-gi-language="c">
	<div class="row">
		
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
	<button id="offcanvasleft" class="btn btn-xs" type="button" data-toggle="offcanvasleft">
		<i class="glyphicon glyphicon-chevron-right" id="offcanvasleft-chevron"></i>
	</button>
</div>

<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="content-column">

	<div id="main">
				    <div id="page-description" data-hotdoc-source="memory.markdown">
        <h1 id="gmemvtable">GMemVTable</h1>
    </div>
        

        



            <h2 class="symbol_section" id="Functions">Functions</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_try_malloc_n">
		
<h3 id="g_try_malloc_n1">
	<span><code>g_try_malloc_n</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_try_malloc_n (gsize n_blocks,
                gsize n_block_bytes)</pre>

<p>This function is similar to <a href="memory.html#g_try_malloc">g_try_malloc</a>, allocating (@n_blocks * <em>n_block_bytes</em>) bytes,
but care is taken to detect possible overflow during multiplication.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>n_blocks:</code></em></i>
		</p>
	</td>
		<td><p>the number of blocks to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_block_bytes:</code></em></i>
		</p>
	</td>
		<td><p>the size of each block in bytes</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the allocated memory, or <a href="macros.html#NULL">NULL</a>.</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="deprecated:2.46;" id="g_mem_profile">
		
<h3 id="g_mem_profile1">
	<span><code>g_mem_profile</code></span>
</h3>

		

<pre class="prototype">
void
g_mem_profile ()</pre>

<p>GLib used to support some tools for memory profiling, but this
no longer works. There are many other useful tools for memory
profiling these days which can be used instead.</p>




	<p>
	deprecated			: 2.46: Use other memory profiling tools instead
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_try_malloc">
		
<h3 id="g_try_malloc1">
	<span><code>g_try_malloc</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_try_malloc (gsize n_bytes)</pre>

<p>Attempts to allocate <em>n_bytes</em>, and returns <a href="macros.html#NULL">NULL</a> on failure.
Contrast with <a href="memory.html#g_malloc">g_malloc</a>, which aborts the program on failure.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters1">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>n_bytes:</code></em></i>
		</p>
	</td>
		<td><p>number of bytes to allocate.</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns1">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the allocated memory, or <a href="macros.html#NULL">NULL</a>.</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_realloc_n">
		
<h3 id="g_realloc_n1">
	<span><code>g_realloc_n</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_realloc_n (gpointer mem,
             gsize n_blocks,
             gsize n_block_bytes)</pre>

<p>This function is similar to <a href="memory.html#g_realloc">g_realloc</a>, allocating (@n_blocks * <em>n_block_bytes</em>) bytes,
but care is taken to detect possible overflow during multiplication.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters2">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mem:</code></em></i>
		</p>
	</td>
		<td><p>the memory to reallocate</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_blocks:</code></em></i>
		</p>
	</td>
		<td><p>the number of blocks to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_block_bytes:</code></em></i>
		</p>
	</td>
		<td><p>the size of each block in bytes</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns2">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the new address of the allocated memory</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_malloc0">
		
<h3 id="g_malloc01">
	<span><code>g_malloc0</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_malloc0 (gsize n_bytes)</pre>

<p>Allocates <em>n_bytes</em> bytes of memory, initialized to 0's.
If <em>n_bytes</em> is 0 it returns <a href="macros.html#NULL">NULL</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters3">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>n_bytes:</code></em></i>
		</p>
	</td>
		<td><p>the number of bytes to allocate</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns3">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the allocated memory</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_malloc0_n">
		
<h3 id="g_malloc0_n1">
	<span><code>g_malloc0_n</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_malloc0_n (gsize n_blocks,
             gsize n_block_bytes)</pre>

<p>This function is similar to <a href="memory.html#g_malloc0">g_malloc0</a>, allocating (@n_blocks * <em>n_block_bytes</em>) bytes,
but care is taken to detect possible overflow during multiplication.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters4">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>n_blocks:</code></em></i>
		</p>
	</td>
		<td><p>the number of blocks to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_block_bytes:</code></em></i>
		</p>
	</td>
		<td><p>the size of each block in bytes</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns4">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the allocated memory</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.34;" id="g_clear_pointer">
		
<h3 id="g_clear_pointer1">
	<span><code>g_clear_pointer</code></span>
</h3>

		

<pre class="prototype">
void
g_clear_pointer (gpointer* pp,
                 <a title="GDestroyNotify" href="datasets.html#GDestroyNotify">GDestroyNotify</a> destroy)</pre>

<p>Clears a reference to a variable.</p>
<p><em>pp</em> must not be <a href="macros.html#NULL">NULL</a>.</p>
<p>If the reference is <a href="macros.html#NULL">NULL</a> then this function does nothing.
Otherwise, the variable is destroyed using <em>destroy</em> and the
pointer is set to <a href="macros.html#NULL">NULL</a>.</p>
<p>A macro is also included that allows this function to be used without
pointer casts.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters5">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>pp:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a variable, struct member etc. holding a
pointer</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>destroy:</code></em></i>
		</p>
	</td>
		<td><p>a function to which a gpointer can be passed, to destroy *@pp</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.34
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_try_malloc0_n">
		
<h3 id="g_try_malloc0_n1">
	<span><code>g_try_malloc0_n</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_try_malloc0_n (gsize n_blocks,
                 gsize n_block_bytes)</pre>

<p>This function is similar to <a href="memory.html#g_try_malloc0">g_try_malloc0</a>, allocating (@n_blocks * <em>n_block_bytes</em>) bytes,
but care is taken to detect possible overflow during multiplication.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters6">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>n_blocks:</code></em></i>
		</p>
	</td>
		<td><p>the number of blocks to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_block_bytes:</code></em></i>
		</p>
	</td>
		<td><p>the size of each block in bytes</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns5">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the allocated memory, or <a href="macros.html#NULL">NULL</a></p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.8;" id="g_try_malloc0">
		
<h3 id="g_try_malloc01">
	<span><code>g_try_malloc0</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_try_malloc0 (gsize n_bytes)</pre>

<p>Attempts to allocate <em>n_bytes</em>, initialized to 0's, and returns <a href="macros.html#NULL">NULL</a> on
failure. Contrast with <a href="memory.html#g_malloc0">g_malloc0</a>, which aborts the program on failure.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters7">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>n_bytes:</code></em></i>
		</p>
	</td>
		<td><p>number of bytes to allocate</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns6">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the allocated memory, or <a href="macros.html#NULL">NULL</a></p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.8
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_free">
		
<h3 id="g_free1">
	<span><code>g_free</code></span>
</h3>

		

<pre class="prototype">
void
g_free (gpointer mem)</pre>

<p>Frees the memory pointed to by <em>mem</em>.</p>
<p>If <em>mem</em> is <a href="macros.html#NULL">NULL</a> it simply returns, so there is no need to check <em>mem</em>
against <a href="macros.html#NULL">NULL</a> before calling this function.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters8">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mem:</code></em></i>
		</p>
	</td>
		<td><p>the memory to free</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_malloc_n">
		
<h3 id="g_malloc_n1">
	<span><code>g_malloc_n</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_malloc_n (gsize n_blocks,
            gsize n_block_bytes)</pre>

<p>This function is similar to <a href="memory.html#g_malloc">g_malloc</a>, allocating (@n_blocks * <em>n_block_bytes</em>) bytes,
but care is taken to detect possible overflow during multiplication.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters9">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>n_blocks:</code></em></i>
		</p>
	</td>
		<td><p>the number of blocks to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_block_bytes:</code></em></i>
		</p>
	</td>
		<td><p>the size of each block in bytes</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns7">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the allocated memory</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_try_realloc">
		
<h3 id="g_try_realloc1">
	<span><code>g_try_realloc</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_try_realloc (gpointer mem,
               gsize n_bytes)</pre>

<p>Attempts to realloc <em>mem</em> to a new size, <em>n_bytes</em>, and returns <a href="macros.html#NULL">NULL</a>
on failure. Contrast with <a href="memory.html#g_realloc">g_realloc</a>, which aborts the program
on failure.</p>
<p>If <em>mem</em> is <a href="macros.html#NULL">NULL</a>, behaves the same as <a href="memory.html#g_try_malloc">g_try_malloc</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters10">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mem:</code></em></i>
		</p>
	</td>
		<td><p>previously-allocated memory, or <a href="macros.html#NULL">NULL</a>.</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_bytes:</code></em></i>
		</p>
	</td>
		<td><p>number of bytes to allocate.</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns8">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the allocated memory, or <a href="macros.html#NULL">NULL</a>.</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_malloc">
		
<h3 id="g_malloc1">
	<span><code>g_malloc</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_malloc (gsize n_bytes)</pre>

<p>Allocates <em>n_bytes</em> bytes of memory.
If <em>n_bytes</em> is 0 it returns <a href="macros.html#NULL">NULL</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters11">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>n_bytes:</code></em></i>
		</p>
	</td>
		<td><p>the number of bytes to allocate</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns9">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the allocated memory</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="deprecated:2.46;" id="g_mem_is_system_malloc">
		
<h3 id="g_mem_is_system_malloc1">
	<span><code>g_mem_is_system_malloc</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_mem_is_system_malloc ()</pre>

<p>Checks whether the allocator used by <a href="memory.html#g_malloc">g_malloc</a> is the system's
malloc implementation. If it returns <a href="macros.html#TRUE">TRUE</a> memory allocated with
malloc can be used interchangeable with memory allocated using <a href="memory.html#g_malloc">g_malloc</a>.
This function is useful for avoiding an extra copy of allocated memory returned
by a non-GLib-based API.</p>


	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns10">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>if <a href="macros.html#TRUE">TRUE</a>, malloc and <a href="memory.html#g_malloc">g_malloc</a> can be mixed.</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	deprecated			: 2.46: GLib always uses the system malloc, so this function always
 returns %TRUE.
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_memdup">
		
<h3 id="g_memdup1">
	<span><code>g_memdup</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_memdup (gconstpointer mem,
          guint byte_size)</pre>

<p>Allocates <em>byte_size</em> bytes of memory, and copies <em>byte_size</em> bytes into it
from <em>mem</em>. If <em>mem</em> is <a href="macros.html#NULL">NULL</a> it returns <a href="macros.html#NULL">NULL</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters12">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mem:</code></em></i>
		</p>
	</td>
		<td><p>the memory to copy.</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>byte_size:</code></em></i>
		</p>
	</td>
		<td><p>the number of bytes to copy.</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns11">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the newly-allocated copy of the memory, or <a href="macros.html#NULL">NULL</a> if <em>mem</em>
is <a href="macros.html#NULL">NULL</a>.</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_try_realloc_n">
		
<h3 id="g_try_realloc_n1">
	<span><code>g_try_realloc_n</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_try_realloc_n (gpointer mem,
                 gsize n_blocks,
                 gsize n_block_bytes)</pre>

<p>This function is similar to <a href="memory.html#g_try_realloc">g_try_realloc</a>, allocating (@n_blocks * <em>n_block_bytes</em>) bytes,
but care is taken to detect possible overflow during multiplication.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters13">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mem:</code></em></i>
		</p>
	</td>
		<td><p>previously-allocated memory, or <a href="macros.html#NULL">NULL</a>.</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_blocks:</code></em></i>
		</p>
	</td>
		<td><p>the number of blocks to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_block_bytes:</code></em></i>
		</p>
	</td>
		<td><p>the size of each block in bytes</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns12">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the allocated memory, or <a href="macros.html#NULL">NULL</a>.</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_realloc">
		
<h3 id="g_realloc1">
	<span><code>g_realloc</code></span>
</h3>

		

<pre class="prototype">
gpointer
g_realloc (gpointer mem,
           gsize n_bytes)</pre>

<p>Reallocates the memory pointed to by <em>mem</em>, so that it now has space for
<em>n_bytes</em> bytes of memory. It returns the new address of the memory, which may
have been moved. <em>mem</em> may be <a href="macros.html#NULL">NULL</a>, in which case it's considered to
have zero-length. <em>n_bytes</em> may be 0, in which case <a href="macros.html#NULL">NULL</a> will be returned
and <em>mem</em> will be freed unless it is <a href="macros.html#NULL">NULL</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters14">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mem:</code></em></i>
		</p>
	</td>
		<td><p>the memory to reallocate</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_bytes:</code></em></i>
		</p>
	</td>
		<td><p>new size of the memory in bytes</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns13">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the new address of the allocated memory</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="deprecated:2.46;" id="g_mem_set_vtable">
		
<h3 id="g_mem_set_vtable1">
	<span><code>g_mem_set_vtable</code></span>
</h3>

		

<pre class="prototype">
void
g_mem_set_vtable (<a title="GMemVTable" href="memory.html#GMemVTable">GMemVTable</a> * vtable)</pre>

<p>This function used to let you override the memory allocation function.
However, its use was incompatible with the use of global constructors
in GLib and GIO, because those use the GLib allocators before main is
reached. Therefore this function is now deprecated and is just a stub.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters15">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>vtable:</code></em></i>
		</p>
	</td>
		<td><p>table of memory allocation routines.</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	deprecated			: 2.46: Use other memory profiling tools instead
		</p>

</div>




            <h2 class="symbol_section" id="Function_Macros">Function Macros</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="g_new">
		
<h3 id="g_new1">
	<span><code>g_new</code></span>
</h3>

		<pre class="raw_code">
#define g_new(struct_type, n_structs)			_G_NEW (struct_type, n_structs, malloc)
</pre>

<p>Allocates <em>n_structs</em> elements of type <em>struct_type</em>.
The returned pointer is cast to a pointer to the given type.
If <em>n_structs</em> is 0 it returns <a href="macros.html#NULL">NULL</a>.
Care is taken to avoid overflow when calculating the size of the allocated block.</p>
<p>Since the returned pointer is already casted to the right type,
it is normally unnecessary to cast it explicitly, and doing
so might hide memory allocation errors.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters16">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>struct_type:</code></em></i>
		</p>
	</td>
		<td><p>the type of the elements to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_structs:</code></em></i>
		</p>
	</td>
		<td><p>the number of elements to allocate</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns14">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the allocated memory, cast to a pointer to <em>struct_type</em></p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_alloca">
		
<h3 id="g_alloca1">
	<span><code>g_alloca</code></span>
</h3>

		<pre class="raw_code">
#define g_alloca(size)		 alloca (size)
</pre>

<p>Allocates <em>size</em> bytes on the stack; these bytes will be freed when the current
stack frame is cleaned up. This macro essentially just wraps the <a href="main.html#alloca">alloca</a>
function present on most UNIX variants.
Thus it provides the same advantages and pitfalls as <a href="main.html#alloca">alloca</a>:</p>
<ul>
<li>
<p><a href="main.html#alloca">alloca</a> is very fast, as on most systems it's implemented by just adjusting
the stack pointer register.</p>
</li>
<li>
<p>It doesn't cause any memory fragmentation, within its scope, separate <a href="main.html#alloca">alloca</a>
blocks just build up and are released together at function end.</p>
</li>
<li>
<p>Allocation sizes have to fit into the current stack frame. For instance in a
threaded environment on Linux, the per-thread stack size is limited to 2 Megabytes,
so be sparse with <a href="main.html#alloca">alloca</a> uses.</p>
</li>
<li>
<p>Allocation failure due to insufficient stack space is not indicated with a <a href="macros.html#NULL">NULL</a>
return like e.g. with malloc. Instead, most systems probably handle it the same
way as out of stack space situations from infinite function recursion, i.e.
with a segmentation fault.</p>
</li>
<li>
<p>Special care has to be taken when mixing <a href="main.html#alloca">alloca</a> with GNU C variable sized arrays.
Stack space allocated with <a href="main.html#alloca">alloca</a> in the same scope as a variable sized array
will be freed together with the variable sized array upon exit of that scope, and
not upon exit of the enclosing function scope.</p>
</li>
</ul>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters17">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>size:</code></em></i>
		</p>
	</td>
		<td><p>number of bytes to allocate.</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns15">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>space for <em>size</em> bytes, allocated on the stack</p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_renew">
		
<h3 id="g_renew1">
	<span><code>g_renew</code></span>
</h3>

		<pre class="raw_code">
#define g_renew(struct_type, mem, n_structs)		_G_RENEW (struct_type, mem, n_structs, realloc)
</pre>

<p>Reallocates the memory pointed to by <em>mem</em>, so that it now has space for
<em>n_structs</em> elements of type <em>struct_type</em>. It returns the new address of
the memory, which may have been moved.
Care is taken to avoid overflow when calculating the size of the allocated block.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters18">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>struct_type:</code></em></i>
		</p>
	</td>
		<td><p>the type of the elements to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>mem:</code></em></i>
		</p>
	</td>
		<td><p>the currently allocated memory</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_structs:</code></em></i>
		</p>
	</td>
		<td><p>the number of elements to allocate</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns16">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the new allocated memory, cast to a pointer to <em>struct_type</em></p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.8;" id="g_try_renew">
		
<h3 id="g_try_renew1">
	<span><code>g_try_renew</code></span>
</h3>

		<pre class="raw_code">
#define g_try_renew(struct_type, mem, n_structs)	_G_RENEW (struct_type, mem, n_structs, try_realloc)
</pre>

<p>Attempts to reallocate the memory pointed to by <em>mem</em>, so that it now has
space for <em>n_structs</em> elements of type <em>struct_type</em>, and returns <a href="macros.html#NULL">NULL</a> on
failure. Contrast with <a href="memory.html#g_renew">g_renew</a>, which aborts the program on failure.
It returns the new address of the memory, which may have been moved.
The function returns <a href="macros.html#NULL">NULL</a> if an overflow occurs.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters19">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>struct_type:</code></em></i>
		</p>
	</td>
		<td><p>the type of the elements to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>mem:</code></em></i>
		</p>
	</td>
		<td><p>the currently allocated memory</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_structs:</code></em></i>
		</p>
	</td>
		<td><p>the number of elements to allocate</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns17">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the new allocated memory, cast to a pointer to <em>struct_type</em></p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.8;" id="g_try_new">
		
<h3 id="g_try_new1">
	<span><code>g_try_new</code></span>
</h3>

		<pre class="raw_code">
#define g_try_new(struct_type, n_structs)		_G_NEW (struct_type, n_structs, try_malloc)
</pre>

<p>Attempts to allocate <em>n_structs</em> elements of type <em>struct_type</em>, and returns
<a href="macros.html#NULL">NULL</a> on failure. Contrast with <a href="memory.html#g_new">g_new</a>, which aborts the program on failure.
The returned pointer is cast to a pointer to the given type.
The function returns <a href="macros.html#NULL">NULL</a> when <em>n_structs</em> is 0 of if an overflow occurs.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters20">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>struct_type:</code></em></i>
		</p>
	</td>
		<td><p>the type of the elements to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_structs:</code></em></i>
		</p>
	</td>
		<td><p>the number of elements to allocate</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns18">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the allocated memory, cast to a pointer to <em>struct_type</em></p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.44;" id="g_steal_pointer">
		
<h3 id="g_steal_pointer1">
	<span><code>g_steal_pointer</code></span>
</h3>

		<pre class="raw_code">
#define g_steal_pointer(pp) \
  (0 ? (*(pp)) : (g_steal_pointer) (pp))
</pre>

<p>Sets <em>pp</em> to <a href="macros.html#NULL">NULL</a>, returning the value that was there before.</p>
<p>Conceptually, this transfers the ownership of the pointer from the
referenced variable to the "caller" of the macro (ie: "steals" the
reference).</p>
<p>The return value will be properly typed, according to the type of
<em>pp</em>.</p>
<p>This can be very useful when combined with <a href="macros_misc.html#g_autoptr">g_autoptr</a> to prevent the
return value of a function from being automatically freed.  Consider
the following example (which only works on GCC and clang):</p>
<pre><code class="language-["> GObject *
 create_object (void)
 {
   g_autoptr(GObject) obj = g_object_new (G_TYPE_OBJECT, NULL);

   if (early_error_case)
     return NULL;

   return g_steal_pointer (&amp;obj);
 }
</code></pre>
<p>It can also be used in similar ways for 'out' parameters and is
particularly useful for dealing with optional out parameters:</p>
<pre><code class="language-["> gboolean
 get_object (GObject **obj_out)
 {
   g_autoptr(GObject) obj = g_object_new (G_TYPE_OBJECT, NULL);

   if (early_error_case)
     return FALSE;

   if (obj_out)
     *obj_out = g_steal_pointer (&amp;obj);

   return TRUE;
 }
</code></pre>
<p>In the above example, the object will be automatically freed in the
early error case and also in the case that <a href="macros.html#NULL">NULL</a> was given for
<em>obj_out</em>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters21">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>pp:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a pointer</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="deprecated:2.40;" id="g_memmove">
		
<h3 id="g_memmove1">
	<span><code>g_memmove</code></span>
</h3>

		<pre class="raw_code">
#define g_memmove(dest,src,len) G_STMT_START { memmove ((dest), (src), (len)); } G_STMT_END
</pre>

<p>Copies a block of memory <em>len</em> bytes long, from <em>src</em> to <em>dest</em>.
The source and destination areas may overlap.</p>





</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_new0">
		
<h3 id="g_new01">
	<span><code>g_new0</code></span>
</h3>

		<pre class="raw_code">
#define g_new0(struct_type, n_structs)			_G_NEW (struct_type, n_structs, malloc0)
</pre>

<p>Allocates <em>n_structs</em> elements of type <em>struct_type</em>, initialized to 0's.
The returned pointer is cast to a pointer to the given type.
If <em>n_structs</em> is 0 it returns <a href="macros.html#NULL">NULL</a>.
Care is taken to avoid overflow when calculating the size of the allocated block.</p>
<p>Since the returned pointer is already casted to the right type,
it is normally unnecessary to cast it explicitly, and doing
so might hide memory allocation errors.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters22">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>struct_type:</code></em></i>
		</p>
	</td>
		<td><p>the type of the elements to allocate.</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_structs:</code></em></i>
		</p>
	</td>
		<td><p>the number of elements to allocate.</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns19">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the allocated memory, cast to a pointer to <em>struct_type</em>.</p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.8;" id="g_try_new0">
		
<h3 id="g_try_new01">
	<span><code>g_try_new0</code></span>
</h3>

		<pre class="raw_code">
#define g_try_new0(struct_type, n_structs)		_G_NEW (struct_type, n_structs, try_malloc0)
</pre>

<p>Attempts to allocate <em>n_structs</em> elements of type <em>struct_type</em>, initialized
to 0's, and returns <a href="macros.html#NULL">NULL</a> on failure. Contrast with <a href="memory.html#g_new0">g_new0</a>, which aborts
the program on failure.
The returned pointer is cast to a pointer to the given type.
The function returns <a href="macros.html#NULL">NULL</a> when <em>n_structs</em> is 0 or if an overflow occurs.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters23">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>struct_type:</code></em></i>
		</p>
	</td>
		<td><p>the type of the elements to allocate</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_structs:</code></em></i>
		</p>
	</td>
		<td><p>the number of elements to allocate</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns20">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a pointer to the allocated memory, cast to a pointer to <em>struct_type</em></p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_newa">
		
<h3 id="g_newa1">
	<span><code>g_newa</code></span>
</h3>

		<pre class="raw_code">
#define g_newa(struct_type, n_structs)	((struct_type*) g_alloca (sizeof (struct_type) * (gsize) (n_structs)))
</pre>

<p>Wraps <a href="memory.html#g_alloca">g_alloca</a> in a more typesafe manner.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters24">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>struct_type:</code></em></i>
		</p>
	</td>
		<td><p>Type of memory chunks to be allocated</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>n_structs:</code></em></i>
		</p>
	</td>
		<td><p>Number of chunks to be allocated</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns21">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>Pointer to stack space for <em>n_structs</em> chunks of type <em>struct_type</em></p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>




            <h2 class="symbol_section" id="Structures">Structures</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="GMemVTable">
		
<h3 id="struct-gmemvtable">
		struct GMemVTable
	</h3>

		<pre class="raw_code">
struct GMemVTable {
    gpointer malloc (gsize n_bytes);
    gpointer realloc (gpointer mem, gsize n_bytes);
    void free (gpointer mem);
    gpointer calloc (gsize n_blocks, gsize n_block_bytes);
    gpointer try_malloc (gsize n_bytes);
    gpointer try_realloc (gpointer mem, gsize n_bytes);
};
</pre>

<p>A set of functions used to perform memory allocation. The same <a href="memory.html#GMemVTable">GMemVTable</a> must
be used for all allocations in the same program; a call to <a href="memory.html#g_mem_set_vtable">g_mem_set_vtable</a>,
if it exists, should be prior to any use of GLib.</p>
<p>This functions related to this has been deprecated in 2.46, and no longer work.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="fields">Fields</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr id="GMemVTable.malloc()">
		<td>
		<p>
		<i><em><code>gpointer <em><code>malloc()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMemVTable.realloc()">
		<td>
		<p>
		<i><em><code>gpointer <em><code>realloc()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMemVTable.free()">
		<td>
		<p>
		<i><em><code>void <em><code>free()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMemVTable.calloc()">
		<td>
		<p>
		<i><em><code>gpointer <em><code>calloc()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMemVTable.try_malloc()">
		<td>
		<p>
		<i><em><code>gpointer <em><code>try_malloc()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GMemVTable.try_realloc()">
		<td>
		<p>
		<i><em><code>gpointer <em><code>try_realloc()</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>






		<div id="subpages"></div>
		</div>
		<div id="search_results">
			<p>The results of the search are</p>
		</div>
	</div>

</div>

<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2">
	<div id="toc-column">
		
					<div class="edit-button">
				

			</div>
				<div id="toc-wrapper">
			<nav id="toc"></nav>
		</div>
	</div>
</div>
	</div>

</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-lg-3 col-xl-2" id="footer-left-column"></div>
		<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="footer-content-column">
						    

		</div>
		<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2" id="footer-right-column"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>