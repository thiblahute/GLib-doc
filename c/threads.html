<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>GMutexLocker</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/utils.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/navigation.js"></script>


<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>


</head>

<body data-spy="scroll" data-target="#toc" data-offset="70">

<nav class="navbar navbar-fixed-top navbar-default">
	<div class="container-fluid">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a id="home-link" class="hotdoc-navbar-brand">
				
<img src="assets/images/home.svg" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
							</ul>
						<form action="" class="navbar-form navbar-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                       </form>
		</div>
	</div>
</nav>

<main class="page-row page-row-expanded">
<div data-extension="gi-extension" data-hotdoc-in-toplevel="True" data-hotdoc-project="GLib-2.0" data-hotdoc-ref="threads.html" class="page_container" id="page-wrapper" data-hotdoc-meta-gi-languages="c,python,javascript" data-hotdoc-meta-gi-language="c">
	<div class="row">
		
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 col-xl-2" id="sidenav-column">
	<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
		<div id="sitenav-wrapper">
			<div class="sidenav-main-panel-body">
				<div id="site-navigation">
				</div>
			</div>
		</div>
	</div>
	<button id="offcanvasleft" class="btn btn-xs" type="button" data-toggle="offcanvasleft">
		<i class="glyphicon glyphicon-chevron-right" id="offcanvasleft-chevron"></i>
	</button>
</div>

<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="content-column">

	<div id="main">
				    <div id="page-description" data-hotdoc-source="threads.markdown">
        <h1 id="gmutexlocker">GMutexLocker</h1>
    </div>
        

            <h2 class="symbol_section" id="">GRWLock</h2>
        



            <h3 class="symbol_section" id="GRWLockMethods">Methods</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rw_lock_writer_trylock">
		
<h4 id="g_rw_lock_writer_trylock1">
	<span><code>g_rw_lock_writer_trylock</code></span>
</h4>

		

<pre class="prototype">
gboolean
g_rw_lock_writer_trylock (<a title="GRWLock" href="threads.html#GRWLock">GRWLock</a> * rw_lock)</pre>

<p>Tries to obtain a write lock on <em>rw_lock</em>. If any other thread holds
a read or write lock on <em>rw_lock</em>, it immediately returns <a href="macros.html#FALSE">FALSE</a>.
Otherwise it locks <em>rw_lock</em> and returns <a href="macros.html#TRUE">TRUE</a>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rw_lock:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRWLock">GRWLock</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if <em>rw_lock</em> could be locked</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rw_lock_reader_lock">
		
<h4 id="g_rw_lock_reader_lock1">
	<span><code>g_rw_lock_reader_lock</code></span>
</h4>

		

<pre class="prototype">
void
g_rw_lock_reader_lock (<a title="GRWLock" href="threads.html#GRWLock">GRWLock</a> * rw_lock)</pre>

<p>Obtain a read lock on <em>rw_lock</em>. If another thread currently holds
the write lock on <em>rw_lock</em> or blocks waiting for it, the current
thread will block. Read locks can be taken recursively.</p>
<p>It is implementation-defined how many threads are allowed to
hold read locks on the same lock simultaneously.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters1">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rw_lock:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRWLock">GRWLock</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rw_lock_writer_unlock">
		
<h4 id="g_rw_lock_writer_unlock1">
	<span><code>g_rw_lock_writer_unlock</code></span>
</h4>

		

<pre class="prototype">
void
g_rw_lock_writer_unlock (<a title="GRWLock" href="threads.html#GRWLock">GRWLock</a> * rw_lock)</pre>

<p>Release a write lock on <em>rw_lock</em>.</p>
<p>Calling <a href="threads.html#g_rw_lock_writer_unlock">g_rw_lock_writer_unlock</a> on a lock that is not held
by the current thread leads to undefined behaviour.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters2">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rw_lock:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRWLock">GRWLock</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rw_lock_init">
		
<h4 id="g_rw_lock_init1">
	<span><code>g_rw_lock_init</code></span>
</h4>

		

<pre class="prototype">
void
g_rw_lock_init (<a title="GRWLock" href="threads.html#GRWLock">GRWLock</a> * rw_lock)</pre>

<p>Initializes a <a href="threads.html#GRWLock">GRWLock</a> so that it can be used.</p>
<p>This function is useful to initialize a lock that has been
allocated on the stack, or as part of a larger structure.  It is not
necessary to initialise a reader-writer lock that has been statically
allocated.</p>
<pre><code class="language-[&lt;!--">   typedef struct {
     GRWLock l;
     ...
   } Blob;

 Blob *b;

 b = g_new (Blob, 1);
 g_rw_lock_init (&amp;b-&gt;l);
</code></pre>
<p>To undo the effect of <a href="threads.html#g_rw_lock_init">g_rw_lock_init</a> when a lock is no longer
needed, use <a href="threads.html#g_rw_lock_clear">g_rw_lock_clear</a>.</p>
<p>Calling <a href="threads.html#g_rw_lock_init">g_rw_lock_init</a> on an already initialized <a href="threads.html#GRWLock">GRWLock</a> leads
to undefined behaviour.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters3">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rw_lock:</code></em></i>
		</p>
	</td>
		<td><p>an uninitialized <a href="threads.html#GRWLock">GRWLock</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_rw_lock_clear">
		
<h4 id="g_rw_lock_clear1">
	<span><code>g_rw_lock_clear</code></span>
</h4>

		

<pre class="prototype">
void
g_rw_lock_clear (<a title="GRWLock" href="threads.html#GRWLock">GRWLock</a> * rw_lock)</pre>

<p>Frees the resources allocated to a lock with <a href="threads.html#g_rw_lock_init">g_rw_lock_init</a>.</p>
<p>This function should not be used with a <a href="threads.html#GRWLock">GRWLock</a> that has been
statically allocated.</p>
<p>Calling <a href="threads.html#g_rw_lock_clear">g_rw_lock_clear</a> when any thread holds the lock
leads to undefined behaviour.</p>
<p>Sine: 2.32</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters4">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rw_lock:</code></em></i>
		</p>
	</td>
		<td><p>an initialized <a href="threads.html#GRWLock">GRWLock</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rw_lock_writer_lock">
		
<h4 id="g_rw_lock_writer_lock1">
	<span><code>g_rw_lock_writer_lock</code></span>
</h4>

		

<pre class="prototype">
void
g_rw_lock_writer_lock (<a title="GRWLock" href="threads.html#GRWLock">GRWLock</a> * rw_lock)</pre>

<p>Obtain a write lock on <em>rw_lock</em>. If any thread already holds
a read or write lock on <em>rw_lock</em>, the current thread will block
until all other threads have dropped their locks on <em>rw_lock</em>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters5">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rw_lock:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRWLock">GRWLock</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rw_lock_reader_trylock">
		
<h4 id="g_rw_lock_reader_trylock1">
	<span><code>g_rw_lock_reader_trylock</code></span>
</h4>

		

<pre class="prototype">
gboolean
g_rw_lock_reader_trylock (<a title="GRWLock" href="threads.html#GRWLock">GRWLock</a> * rw_lock)</pre>

<p>Tries to obtain a read lock on <em>rw_lock</em> and returns <a href="macros.html#TRUE">TRUE</a> if
the read lock was successfully obtained. Otherwise it
returns <a href="macros.html#FALSE">FALSE</a>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters6">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rw_lock:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRWLock">GRWLock</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns1">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if <em>rw_lock</em> could be locked</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rw_lock_reader_unlock">
		
<h4 id="g_rw_lock_reader_unlock1">
	<span><code>g_rw_lock_reader_unlock</code></span>
</h4>

		

<pre class="prototype">
void
g_rw_lock_reader_unlock (<a title="GRWLock" href="threads.html#GRWLock">GRWLock</a> * rw_lock)</pre>

<p>Release a read lock on <em>rw_lock</em>.</p>
<p>Calling <a href="threads.html#g_rw_lock_reader_unlock">g_rw_lock_reader_unlock</a> on a lock that is not held
by the current thread leads to undefined behaviour.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters7">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rw_lock:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRWLock">GRWLock</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>



            <h2 class="symbol_section" id="">GCond</h2>
        



            <h3 class="symbol_section" id="GCondMethods">Methods</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_cond_init">
		
<h4 id="g_cond_init1">
	<span><code>g_cond_init</code></span>
</h4>

		

<pre class="prototype">
void
g_cond_init (<a title="GCond" href="threads.html#GCond">GCond</a> * cond)</pre>

<p>Initialises a <a href="threads.html#GCond">GCond</a> so that it can be used.</p>
<p>This function is useful to initialise a <a href="threads.html#GCond">GCond</a> that has been
allocated as part of a larger structure.  It is not necessary to
initialise a <a href="threads.html#GCond">GCond</a> that has been statically allocated.</p>
<p>To undo the effect of <a href="threads.html#g_cond_init">g_cond_init</a> when a <a href="threads.html#GCond">GCond</a> is no longer
needed, use <a href="threads.html#g_cond_clear">g_cond_clear</a>.</p>
<p>Calling <a href="threads.html#g_cond_init">g_cond_init</a> on an already-initialised <a href="threads.html#GCond">GCond</a> leads
to undefined behaviour.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters8">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>cond:</code></em></i>
		</p>
	</td>
		<td><p>an uninitialized <a href="threads.html#GCond">GCond</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_cond_signal">
		
<h4 id="g_cond_signal1">
	<span><code>g_cond_signal</code></span>
</h4>

		

<pre class="prototype">
void
g_cond_signal (<a title="GCond" href="threads.html#GCond">GCond</a> * cond)</pre>

<p>If threads are waiting for <em>cond</em>, at least one of them is unblocked.
If no threads are waiting for <em>cond</em>, this function has no effect.
It is good practice to hold the same lock as the waiting thread
while calling this function, though not required.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters9">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>cond:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GCond">GCond</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_cond_broadcast">
		
<h4 id="g_cond_broadcast1">
	<span><code>g_cond_broadcast</code></span>
</h4>

		

<pre class="prototype">
void
g_cond_broadcast (<a title="GCond" href="threads.html#GCond">GCond</a> * cond)</pre>

<p>If threads are waiting for <em>cond</em>, all of them are unblocked.
If no threads are waiting for <em>cond</em>, this function has no effect.
It is good practice to lock the same mutex as the waiting threads
while calling this function, though not required.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters10">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>cond:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GCond">GCond</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_cond_clear">
		
<h4 id="g_cond_clear1">
	<span><code>g_cond_clear</code></span>
</h4>

		

<pre class="prototype">
void
g_cond_clear (<a title="GCond" href="threads.html#GCond">GCond</a> * cond)</pre>

<p>Frees the resources allocated to a <a href="threads.html#GCond">GCond</a> with <a href="threads.html#g_cond_init">g_cond_init</a>.</p>
<p>This function should not be used with a <a href="threads.html#GCond">GCond</a> that has been
statically allocated.</p>
<p>Calling <a href="threads.html#g_cond_clear">g_cond_clear</a> for a <a href="threads.html#GCond">GCond</a> on which threads are
blocking leads to undefined behaviour.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters11">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>cond:</code></em></i>
		</p>
	</td>
		<td><p>an initialised <a href="threads.html#GCond">GCond</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_cond_wait_until">
		
<h4 id="g_cond_wait_until1">
	<span><code>g_cond_wait_until</code></span>
</h4>

		

<pre class="prototype">
gboolean
g_cond_wait_until (<a title="GCond" href="threads.html#GCond">GCond</a> * cond,
                   GMutex* mutex,
                   gint64 end_time)</pre>

<p>Waits until either <em>cond</em> is signalled or <em>end_time</em> has passed.</p>
<p>As with <a href="threads.html#g_cond_wait">g_cond_wait</a> it is possible that a spurious or stolen wakeup
could occur.  For that reason, waiting on a condition variable should
always be in a loop, based on an explicitly-checked predicate.</p>
<p><a href="macros.html#TRUE">TRUE</a> is returned if the condition variable was signalled (or in the
case of a spurious wakeup).  <a href="macros.html#FALSE">FALSE</a> is returned if <em>end_time</em> has
passed.</p>
<p>The following code shows how to correctly perform a timed wait on a
condition variable (extending the example presented in the
documentation for <a href="threads.html#GCond">GCond</a>):</p>
<pre><code class="language-[&lt;!--"> gpointer
 pop_data_timed (void)
 {
   gint64 end_time;
   gpointer data;

   g_mutex_lock (&amp;data_mutex);

   end_time = g_get_monotonic_time () + 5 * G_TIME_SPAN_SECOND;
   while (!current_data)
     if (!g_cond_wait_until (&amp;data_cond, &amp;data_mutex, end_time))
       {
         // timeout has passed.
         g_mutex_unlock (&amp;data_mutex);
         return NULL;
       }

   // there is data for us
   data = current_data;
   current_data = NULL;

   g_mutex_unlock (&amp;data_mutex);

   return data;
 }
</code></pre>
<p>Notice that the end time is calculated once, before entering the
loop and reused.  This is the motivation behind the use of absolute
time on this API -- if a relative time of 5 seconds were passed
directly to the call and a spurious wakeup occurred, the program would
have to start over waiting again (which would lead to a total wait
time of more than 5 seconds).</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters12">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>cond:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GCond">GCond</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>mutex:</code></em></i>
		</p>
	</td>
		<td><p>a GMutex that is currently locked</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>end_time:</code></em></i>
		</p>
	</td>
		<td><p>the monotonic time to wait until</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns2">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> on a signal, <a href="macros.html#FALSE">FALSE</a> on a timeout</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_cond_wait">
		
<h4 id="g_cond_wait1">
	<span><code>g_cond_wait</code></span>
</h4>

		

<pre class="prototype">
void
g_cond_wait (<a title="GCond" href="threads.html#GCond">GCond</a> * cond,
             GMutex* mutex)</pre>

<p>Atomically releases <em>mutex</em> and waits until <em>cond</em> is signalled.
When this function returns, <em>mutex</em> is locked again and owned by the
calling thread.</p>
<p>When using condition variables, it is possible that a spurious wakeup
may occur (ie: <a href="threads.html#g_cond_wait">g_cond_wait</a> returns even though <a href="threads.html#g_cond_signal">g_cond_signal</a> was
not called).  It's also possible that a stolen wakeup may occur.
This is when <a href="threads.html#g_cond_signal">g_cond_signal</a> is called, but another thread acquires
<em>mutex</em> before this thread and modifies the state of the program in
such a way that when <a href="threads.html#g_cond_wait">g_cond_wait</a> is able to return, the expected
condition is no longer met.</p>
<p>For this reason, <a href="threads.html#g_cond_wait">g_cond_wait</a> must always be used in a loop.  See
the documentation for <a href="threads.html#GCond">GCond</a> for a complete example.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters13">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>cond:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GCond">GCond</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>mutex:</code></em></i>
		</p>
	</td>
		<td><p>a GMutex that is currently locked</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>



            <h2 class="symbol_section" id="">GThread</h2>
        



            <h3 class="symbol_section" id="GThreadConstructors">Constructors</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_thread_new">
		
<h4 id="g_thread_new1">
	<span><code>g_thread_new</code></span>
</h4>

		

<pre class="prototype">
<a title="GThread" href="threads.html#GThread">GThread</a> *
g_thread_new (const gchar* name,
              <a title="GThreadFunc" href="threads.html#GThreadFunc">GThreadFunc</a> func,
              gpointer data)</pre>

<p>This function creates a new thread. The new thread starts by invoking
<em>func</em> with the argument data. The thread will run until <em>func</em> returns
or until <a href="threads.html#g_thread_exit">g_thread_exit</a> is called from the new thread. The return value
of <em>func</em> becomes the return value of the thread, which can be obtained
with <a href="threads.html#g_thread_join">g_thread_join</a>.</p>
<p>The <em>name</em> can be useful for discriminating threads in a debugger.
It is not used for other purposes and does not have to be unique.
Some systems restrict the length of <em>name</em> to 16 bytes.</p>
<p>If the thread can not be created the program aborts. See
<a href="threads.html#g_thread_try_new">g_thread_try_new</a> if you want to attempt to deal with failures.</p>
<p>If you are using threads to offload (potentially many) short-lived tasks,
<a href="thread_pools.html#GThreadPool">GThreadPool</a> may be more appropriate than manually spawning and tracking
multiple <a href="threads.html#GThread">GThread</a>.</p>
<p>To free the struct returned by this function, use <a href="threads.html#g_thread_unref">g_thread_unref</a>.
Note that <a href="threads.html#g_thread_join">g_thread_join</a> implicitly unrefs the <a href="threads.html#GThread">GThread</a> as well.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters14">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>name:</code></em></i>
		</p>
	</td>
		<td><p>an (optional) name for the new thread</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>func:</code></em></i>
		</p>
	</td>
		<td><p>a function to execute in the new thread</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>data:</code></em></i>
		</p>
	</td>
		<td><p>an argument to supply to the new thread</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns3">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the new <a href="threads.html#GThread">GThread</a></p>

	</td>
	<td>
		<a title="GThread" href="threads.html#GThread">GThread</a> *
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_thread_try_new">
		
<h4 id="g_thread_try_new1">
	<span><code>g_thread_try_new</code></span>
</h4>

		

<pre class="prototype">
<a title="GThread" href="threads.html#GThread">GThread</a> *
g_thread_try_new (const gchar* name,
                  <a title="GThreadFunc" href="threads.html#GThreadFunc">GThreadFunc</a> func,
                  gpointer data)</pre>

<p>This function is the same as <a href="threads.html#g_thread_new">g_thread_new</a> except that
it allows for the possibility of failure.</p>
<p>If a thread can not be created (due to resource limits),
<em>error</em> is set and <a href="macros.html#NULL">NULL</a> is returned.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters15">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>name:</code></em></i>
		</p>
	</td>
		<td><p>an (optional) name for the new thread</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL may be passed to the value"><span class="acronym">nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>func:</code></em></i>
		</p>
	</td>
		<td><p>a function to execute in the new thread</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>data:</code></em></i>
		</p>
	</td>
		<td><p>an argument to supply to the new thread</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns4">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the new <a href="threads.html#GThread">GThread</a>, or <a href="macros.html#NULL">NULL</a> if an error occurred</p>

	</td>
	<td>
		<a title="GThread" href="threads.html#GThread">GThread</a> *
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.32
		</p>

</div>




            <h3 class="symbol_section" id="GThreadMethods">Methods</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_thread_ref">
		
<h4 id="g_thread_ref1">
	<span><code>g_thread_ref</code></span>
</h4>

		

<pre class="prototype">
<a title="GThread" href="threads.html#GThread">GThread</a> *
g_thread_ref (<a title="GThread" href="threads.html#GThread">GThread</a> * thread)</pre>

<p>Increase the reference count on <em>thread</em>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters16">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>thread:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GThread">GThread</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns5">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>a new reference to <em>thread</em></p>

	</td>
	<td>
		<a title="GThread" href="threads.html#GThread">GThread</a> *
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_thread_unref">
		
<h4 id="g_thread_unref1">
	<span><code>g_thread_unref</code></span>
</h4>

		

<pre class="prototype">
void
g_thread_unref (<a title="GThread" href="threads.html#GThread">GThread</a> * thread)</pre>

<p>Decrease the reference count on <em>thread</em>, possibly freeing all
resources associated with it.</p>
<p>Note that each thread holds a reference to its <a href="threads.html#GThread">GThread</a> while
it is running, so it is safe to drop your own reference to it
if you don't need it anymore.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters17">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>thread:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GThread">GThread</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_thread_join">
		
<h4 id="g_thread_join1">
	<span><code>g_thread_join</code></span>
</h4>

		

<pre class="prototype">
gpointer
g_thread_join (<a title="GThread" href="threads.html#GThread">GThread</a> * thread)</pre>

<p>Waits until <em>thread</em> finishes, i.e. the function <em>func</em>, as
given to <a href="threads.html#g_thread_new">g_thread_new</a>, returns or <a href="threads.html#g_thread_exit">g_thread_exit</a> is called.
If <em>thread</em> has already terminated, then <a href="threads.html#g_thread_join">g_thread_join</a>
returns immediately.</p>
<p>Any thread can wait for any other thread by calling <a href="threads.html#g_thread_join">g_thread_join</a>,
not just its 'creator'. Calling <a href="threads.html#g_thread_join">g_thread_join</a> from multiple threads
for the same <em>thread</em> leads to undefined behaviour.</p>
<p>The value returned by <em>func</em> or given to <a href="threads.html#g_thread_exit">g_thread_exit</a> is
returned by this function.</p>
<p><a href="threads.html#g_thread_join">g_thread_join</a> consumes the reference to the passed-in <em>thread</em>.
This will usually cause the <a href="threads.html#GThread">GThread</a> struct and associated resources
to be freed. Use <a href="threads.html#g_thread_ref">g_thread_ref</a> to obtain an extra reference if you
want to keep the GThread alive beyond the <a href="threads.html#g_thread_join">g_thread_join</a> call.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters18">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>thread:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GThread">GThread</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns6">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the return value of the thread</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>



            <h2 class="symbol_section" id="">GRecMutex</h2>
        



            <h3 class="symbol_section" id="GRecMutexMethods">Methods</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rec_mutex_unlock">
		
<h4 id="g_rec_mutex_unlock1">
	<span><code>g_rec_mutex_unlock</code></span>
</h4>

		

<pre class="prototype">
void
g_rec_mutex_unlock (<a title="GRecMutex" href="threads.html#GRecMutex">GRecMutex</a> * rec_mutex)</pre>

<p>Unlocks <em>rec_mutex</em>. If another thread is blocked in a
<a href="threads.html#g_rec_mutex_lock">g_rec_mutex_lock</a> call for <em>rec_mutex</em>, it will become unblocked
and can lock <em>rec_mutex</em> itself.</p>
<p>Calling <a href="threads.html#g_rec_mutex_unlock">g_rec_mutex_unlock</a> on a recursive mutex that is not
locked by the current thread leads to undefined behaviour.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters19">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rec_mutex:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRecMutex">GRecMutex</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rec_mutex_trylock">
		
<h4 id="g_rec_mutex_trylock1">
	<span><code>g_rec_mutex_trylock</code></span>
</h4>

		

<pre class="prototype">
gboolean
g_rec_mutex_trylock (<a title="GRecMutex" href="threads.html#GRecMutex">GRecMutex</a> * rec_mutex)</pre>

<p>Tries to lock <em>rec_mutex</em>. If <em>rec_mutex</em> is already locked
by another thread, it immediately returns <a href="macros.html#FALSE">FALSE</a>. Otherwise
it locks <em>rec_mutex</em> and returns <a href="macros.html#TRUE">TRUE</a>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters20">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rec_mutex:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRecMutex">GRecMutex</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns7">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if <em>rec_mutex</em> could be locked</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rec_mutex_lock">
		
<h4 id="g_rec_mutex_lock1">
	<span><code>g_rec_mutex_lock</code></span>
</h4>

		

<pre class="prototype">
void
g_rec_mutex_lock (<a title="GRecMutex" href="threads.html#GRecMutex">GRecMutex</a> * rec_mutex)</pre>

<p>Locks <em>rec_mutex</em>. If <em>rec_mutex</em> is already locked by another
thread, the current thread will block until <em>rec_mutex</em> is
unlocked by the other thread. If <em>rec_mutex</em> is already locked
by the current thread, the 'lock count' of <em>rec_mutex</em> is increased.
The mutex will only become available again when it is unlocked
as many times as it has been locked.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters21">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rec_mutex:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GRecMutex">GRecMutex</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_rec_mutex_init">
		
<h4 id="g_rec_mutex_init1">
	<span><code>g_rec_mutex_init</code></span>
</h4>

		

<pre class="prototype">
void
g_rec_mutex_init (<a title="GRecMutex" href="threads.html#GRecMutex">GRecMutex</a> * rec_mutex)</pre>

<p>Initializes a <a href="threads.html#GRecMutex">GRecMutex</a> so that it can be used.</p>
<p>This function is useful to initialize a recursive mutex
that has been allocated on the stack, or as part of a larger
structure.</p>
<p>It is not necessary to initialise a recursive mutex that has been
statically allocated.</p>
<pre><code class="language-[&lt;!--">   typedef struct {
     GRecMutex m;
     ...
   } Blob;

 Blob *b;

 b = g_new (Blob, 1);
 g_rec_mutex_init (&amp;b-&gt;m);
</code></pre>
<p>Calling <a href="threads.html#g_rec_mutex_init">g_rec_mutex_init</a> on an already initialized <a href="threads.html#GRecMutex">GRecMutex</a>
leads to undefined behaviour.</p>
<p>To undo the effect of <a href="threads.html#g_rec_mutex_init">g_rec_mutex_init</a> when a recursive mutex
is no longer needed, use <a href="threads.html#g_rec_mutex_clear">g_rec_mutex_clear</a>.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters22">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rec_mutex:</code></em></i>
		</p>
	</td>
		<td><p>an uninitialized <a href="threads.html#GRecMutex">GRecMutex</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_rec_mutex_clear">
		
<h4 id="g_rec_mutex_clear1">
	<span><code>g_rec_mutex_clear</code></span>
</h4>

		

<pre class="prototype">
void
g_rec_mutex_clear (<a title="GRecMutex" href="threads.html#GRecMutex">GRecMutex</a> * rec_mutex)</pre>

<p>Frees the resources allocated to a recursive mutex with
<a href="threads.html#g_rec_mutex_init">g_rec_mutex_init</a>.</p>
<p>This function should not be used with a <a href="threads.html#GRecMutex">GRecMutex</a> that has been
statically allocated.</p>
<p>Calling <a href="threads.html#g_rec_mutex_clear">g_rec_mutex_clear</a> on a locked recursive mutex leads
to undefined behaviour.</p>
<p>Sine: 2.32</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters23">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>rec_mutex:</code></em></i>
		</p>
	</td>
		<td><p>an initialized <a href="threads.html#GRecMutex">GRecMutex</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>



            <h2 class="symbol_section" id="">GOnce</h2>
        



            <h3 class="symbol_section" id="GOnceMethods">Methods</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="g_once_impl">
		
<h4 id="g_once_impl1">
	<span><code>g_once_impl</code></span>
</h4>

		

<pre class="prototype">
gpointer
g_once_impl (<a title="GOnce" href="threads.html#GOnce">GOnce</a> * once,
             <a title="GThreadFunc" href="threads.html#GThreadFunc">GThreadFunc</a> func,
             gpointer arg)</pre>



	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters24">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>once:</code></em></i>
		</p>
	</td>
		<td></td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>func:</code></em></i>
		</p>
	</td>
		<td></td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>arg:</code></em></i>
		</p>
	</td>
		<td></td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns8">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>



            <h2 class="symbol_section" id="">GPrivate</h2>
        



            <h3 class="symbol_section" id="GPrivateMethods">Methods</h3>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_private_replace">
		
<h4 id="g_private_replace1">
	<span><code>g_private_replace</code></span>
</h4>

		

<pre class="prototype">
void
g_private_replace (<a title="GPrivate" href="threads.html#GPrivate">GPrivate</a> * key,
                   gpointer value)</pre>

<p>Sets the thread local variable <em>key</em> to have the value <em>value</em> in the
current thread.</p>
<p>This function differs from <a href="threads.html#g_private_set">g_private_set</a> in the following way: if
the previous value was non-%NULL then the <a href="datasets.html#GDestroyNotify">GDestroyNotify</a> handler for
<em>key</em> is run on it.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters25">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>key:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GPrivate">GPrivate</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>value:</code></em></i>
		</p>
	</td>
		<td><p>the new value</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_private_set">
		
<h4 id="g_private_set1">
	<span><code>g_private_set</code></span>
</h4>

		

<pre class="prototype">
void
g_private_set (<a title="GPrivate" href="threads.html#GPrivate">GPrivate</a> * key,
               gpointer value)</pre>

<p>Sets the thread local variable <em>key</em> to have the value <em>value</em> in the
current thread.</p>
<p>This function differs from <a href="threads.html#g_private_replace">g_private_replace</a> in the following way:
the <a href="datasets.html#GDestroyNotify">GDestroyNotify</a> for <em>key</em> is not called on the old value.</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters26">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>key:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GPrivate">GPrivate</a></p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>value:</code></em></i>
		</p>
	</td>
		<td><p>the new value</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_private_get">
		
<h4 id="g_private_get1">
	<span><code>g_private_get</code></span>
</h4>

		

<pre class="prototype">
gpointer
g_private_get (<a title="GPrivate" href="threads.html#GPrivate">GPrivate</a> * key)</pre>

<p>Returns the current value of the thread local variable <em>key</em>.</p>
<p>If the value has not yet been set in this thread, <a href="macros.html#NULL">NULL</a> is returned.
Values are never copied between threads (when a new thread is
created, for example).</p>


	<div class="parameter_container">
		<h5 class="always-hide-toc" data-toc-skip="true" id="parameters27">Parameters</h5>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>key:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GPrivate">GPrivate</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h5 class="always-hide-toc" data-toc-skip="true" id="returns9">Returns:</h5>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the thread-local value</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>



        



            <h2 class="symbol_section" id="Methods">Methods</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="g_mutex_trylock">
		
<h3 id="g_mutex_trylock1">
	<span><code>g_mutex_trylock</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_mutex_trylock (GMutex* mutex)</pre>

<p>Tries to lock <em>mutex</em>. If <em>mutex</em> is already locked by another thread,
it immediately returns <a href="macros.html#FALSE">FALSE</a>. Otherwise it locks <em>mutex</em> and returns
<a href="macros.html#TRUE">TRUE</a>.</p>
<p>GMutex is neither guaranteed to be recursive nor to be
non-recursive.  As such, calling <a href="threads.html#g_mutex_lock">g_mutex_lock</a> on a GMutex that has
already been locked by the same thread results in undefined behaviour
(including but not limited to deadlocks or arbitrary return values).</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters28">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mutex:</code></em></i>
		</p>
	</td>
		<td><p>a GMutex</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns10">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if <em>mutex</em> could be locked</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_mutex_unlock">
		
<h3 id="g_mutex_unlock1">
	<span><code>g_mutex_unlock</code></span>
</h3>

		

<pre class="prototype">
void
g_mutex_unlock (GMutex* mutex)</pre>

<p>Unlocks <em>mutex</em>. If another thread is blocked in a <a href="threads.html#g_mutex_lock">g_mutex_lock</a>
call for <em>mutex</em>, it will become unblocked and can lock <em>mutex</em> itself.</p>
<p>Calling <a href="threads.html#g_mutex_unlock">g_mutex_unlock</a> on a mutex that is not locked by the
current thread leads to undefined behaviour.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters29">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mutex:</code></em></i>
		</p>
	</td>
		<td><p>a GMutex</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="g_mutex_init">
		
<h3 id="g_mutex_init1">
	<span><code>g_mutex_init</code></span>
</h3>

		

<pre class="prototype">
void
g_mutex_init (GMutex* mutex)</pre>

<p>Initializes a GMutex so that it can be used.</p>
<p>This function is useful to initialize a mutex that has been
allocated on the stack, or as part of a larger structure.
It is not necessary to initialize a mutex that has been
statically allocated.</p>
<pre><code class="language-[&lt;!--">   typedef struct {
     GMutex m;
     ...
   } Blob;

 Blob *b;

 b = g_new (Blob, 1);
 g_mutex_init (&amp;b-&gt;m);
</code></pre>
<p>To undo the effect of <a href="threads.html#g_mutex_init">g_mutex_init</a> when a mutex is no longer
needed, use <a href="threads.html#g_mutex_clear">g_mutex_clear</a>.</p>
<p>Calling <a href="threads.html#g_mutex_init">g_mutex_init</a> on an already initialized GMutex leads
to undefined behaviour.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters30">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mutex:</code></em></i>
		</p>
	</td>
		<td><p>an uninitialized GMutex</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.32
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_mutex_clear">
		
<h3 id="g_mutex_clear1">
	<span><code>g_mutex_clear</code></span>
</h3>

		

<pre class="prototype">
void
g_mutex_clear (GMutex* mutex)</pre>

<p>Frees the resources allocated to a mutex with <a href="threads.html#g_mutex_init">g_mutex_init</a>.</p>
<p>This function should not be used with a GMutex that has been
statically allocated.</p>
<p>Calling <a href="threads.html#g_mutex_clear">g_mutex_clear</a> on a locked mutex leads to undefined
behaviour.</p>
<p>Sine: 2.32</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters31">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mutex:</code></em></i>
		</p>
	</td>
		<td><p>an initialized GMutex</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_mutex_lock">
		
<h3 id="g_mutex_lock1">
	<span><code>g_mutex_lock</code></span>
</h3>

		

<pre class="prototype">
void
g_mutex_lock (GMutex* mutex)</pre>

<p>Locks <em>mutex</em>. If <em>mutex</em> is already locked by another thread, the
current thread will block until <em>mutex</em> is unlocked by the other
thread.</p>
<p>GMutex is neither guaranteed to be recursive nor to be
non-recursive.  As such, calling <a href="threads.html#g_mutex_lock">g_mutex_lock</a> on a GMutex that has
already been locked by the same thread results in undefined behaviour
(including but not limited to deadlocks).</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters32">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>mutex:</code></em></i>
		</p>
	</td>
		<td><p>a GMutex</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>




            <h2 class="symbol_section" id="Functions">Functions</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="g_thread_exit">
		
<h3 id="g_thread_exit1">
	<span><code>g_thread_exit</code></span>
</h3>

		

<pre class="prototype">
void
g_thread_exit (gpointer retval)</pre>

<p>Terminates the current thread.</p>
<p>If another thread is waiting for us using <a href="threads.html#g_thread_join">g_thread_join</a> then the
waiting thread will be woken up and get <em>retval</em> as the return value
of <a href="threads.html#g_thread_join">g_thread_join</a>.</p>
<p>Calling <a href="threads.html#g_thread_exit">g_thread_exit</a> with a parameter <em>retval</em> is equivalent to
returning <em>retval</em> from the function <em>func</em>, as given to <a href="threads.html#g_thread_new">g_thread_new</a>.</p>
<p>You must only call <a href="threads.html#g_thread_exit">g_thread_exit</a> from a thread that you created
yourself with <a href="threads.html#g_thread_new">g_thread_new</a> or related APIs. You must not call
this function from a thread created with another threading library
or or from within a <a href="thread_pools.html#GThreadPool">GThreadPool</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters33">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>retval:</code></em></i>
		</p>
	</td>
		<td><p>the return value of this thread</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_bit_trylock">
		
<h3 id="g_bit_trylock1">
	<span><code>g_bit_trylock</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_bit_trylock (volatile gint* address,
               gint lock_bit)</pre>

<p>Sets the indicated <em>lock_bit</em> in <em>address</em>, returning <a href="macros.html#TRUE">TRUE</a> if
successful.  If the bit is already set, returns <a href="macros.html#FALSE">FALSE</a> immediately.</p>
<p>Attempting to lock on two different bits within the same integer is
not supported.</p>
<p>The value of the bit that is set is (1u &lt;&lt; <em>bit</em>).  If <em>bit</em> is not
between 0 and 31 then the result is undefined.</p>
<p>This function accesses <em>address</em> atomically.  All other accesses to
<em>address</em> must be atomic in order for this function to work
reliably.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters34">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>address:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to an integer</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>lock_bit:</code></em></i>
		</p>
	</td>
		<td><p>a bit value between 0 and 31</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns11">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if the lock was acquired</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_pointer_bit_unlock">
		
<h3 id="g_pointer_bit_unlock1">
	<span><code>g_pointer_bit_unlock</code></span>
</h3>

		

<pre class="prototype">
void
g_pointer_bit_unlock (void* address,
                      gint lock_bit)</pre>

<p>This is equivalent to g_bit_unlock, but working on pointers (or other
pointer-sized values).</p>
<p>For portability reasons, you may only lock on the bottom 32 bits of
the pointer.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters35">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>address:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>lock_bit:</code></em></i>
		</p>
	</td>
		<td><p>a bit value between 0 and 31</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_thread_error_quark">
		
<h3 id="g_thread_error_quark1">
	<span><code>g_thread_error_quark</code></span>
</h3>

		

<pre class="prototype">
<a title="GQuark" href="quarks.html#GQuark">GQuark</a>
g_thread_error_quark ()</pre>



	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns12">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		
	</td>
	<td>
		<a title="GQuark" href="quarks.html#GQuark">GQuark</a>
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.36;" id="g_get_num_processors">
		
<h3 id="g_get_num_processors1">
	<span><code>g_get_num_processors</code></span>
</h3>

		

<pre class="prototype">
guint
g_get_num_processors ()</pre>

<p>Determine the approximate number of threads that the system will
schedule simultaneously for this process.  This is intended to be
used as a parameter to <a href="thread_pools.html#g_thread_pool_new">g_thread_pool_new</a> for CPU bound tasks and
similar cases.</p>


	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns13">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>Number of schedulable threads, always greater than 0</p>

	</td>
	<td>
		guint
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.36
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_pointer_bit_lock">
		
<h3 id="g_pointer_bit_lock1">
	<span><code>g_pointer_bit_lock</code></span>
</h3>

		

<pre class="prototype">
void
g_pointer_bit_lock (void* address,
                    gint lock_bit)</pre>

<p>This is equivalent to g_bit_lock, but working on pointers (or other
pointer-sized values).</p>
<p>For portability reasons, you may only lock on the bottom 32 bits of
the pointer.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters36">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>address:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>lock_bit:</code></em></i>
		</p>
	</td>
		<td><p>a bit value between 0 and 31</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.14;" id="g_once_init_enter">
		
<h3 id="g_once_init_enter1">
	<span><code>g_once_init_enter</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_once_init_enter (void* location)</pre>

<p>Function to be called when starting a critical initialization
section. The argument <em>location</em> must point to a static
0-initialized variable that will be set to a value other than 0 at
the end of the initialization section. In combination with
<a href="threads.html#g_once_init_leave">g_once_init_leave</a> and the unique address <em>value_location</em>, it can
be ensured that an initialization section will be executed only once
during a program's life time, and that concurrent threads are
blocked until initialization completed. To be used in constructs
like this:</p>
<pre><code class="language-[&lt;!--">   static gsize initialization_value = 0;

   if (g_once_init_enter (&amp;initialization_value))
     {
       gsize setup_value = 42; // initialization code here

       g_once_init_leave (&amp;initialization_value, setup_value);
     }

   // use initialization_value here
</code></pre>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters37">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>location:</code></em></i>
		</p>
	</td>
		<td><p>location of a static initializable variable
containing 0</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns14">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if the initialization section should be entered,
<a href="macros.html#FALSE">FALSE</a> and blocks otherwise</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.14
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_thread_yield">
		
<h3 id="g_thread_yield1">
	<span><code>g_thread_yield</code></span>
</h3>

		

<pre class="prototype">
void
g_thread_yield ()</pre>

<p>Causes the calling thread to voluntarily relinquish the CPU, so
that other threads can run.</p>
<p>This function is often used as a method to make busy wait less evil.</p>





</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_bit_lock">
		
<h3 id="g_bit_lock1">
	<span><code>g_bit_lock</code></span>
</h3>

		

<pre class="prototype">
void
g_bit_lock (volatile gint* address,
            gint lock_bit)</pre>

<p>Sets the indicated <em>lock_bit</em> in <em>address</em>.  If the bit is already
set, this call will block until <a href="threads.html#g_bit_unlock">g_bit_unlock</a> unsets the
corresponding bit.</p>
<p>Attempting to lock on two different bits within the same integer is
not supported and will very probably cause deadlocks.</p>
<p>The value of the bit that is set is (1u &lt;&lt; <em>bit</em>).  If <em>bit</em> is not
between 0 and 31 then the result is undefined.</p>
<p>This function accesses <em>address</em> atomically.  All other accesses to
<em>address</em> must be atomic in order for this function to work
reliably.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters38">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>address:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to an integer</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>lock_bit:</code></em></i>
		</p>
	</td>
		<td><p>a bit value between 0 and 31</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.14;" id="g_once_init_leave">
		
<h3 id="g_once_init_leave1">
	<span><code>g_once_init_leave</code></span>
</h3>

		

<pre class="prototype">
void
g_once_init_leave (void* location,
                   gsize result)</pre>

<p>Counterpart to <a href="threads.html#g_once_init_enter">g_once_init_enter</a>. Expects a location of a static
0-initialized initialization variable, and an initialization value
other than 0. Sets the variable to the initialization value, and
releases concurrent threads blocking in <a href="threads.html#g_once_init_enter">g_once_init_enter</a> on this
initialization variable.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters39">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>location:</code></em></i>
		</p>
	</td>
		<td><p>location of a static initializable variable
containing 0</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>result:</code></em></i>
		</p>
	</td>
		<td><p>new non-0 value for *@value_location</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.14
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.24;" id="g_bit_unlock">
		
<h3 id="g_bit_unlock1">
	<span><code>g_bit_unlock</code></span>
</h3>

		

<pre class="prototype">
void
g_bit_unlock (volatile gint* address,
              gint lock_bit)</pre>

<p>Clears the indicated <em>lock_bit</em> in <em>address</em>.  If another thread is
currently blocked in <a href="threads.html#g_bit_lock">g_bit_lock</a> on this same bit then it will be
woken up.</p>
<p>This function accesses <em>address</em> atomically.  All other accesses to
<em>address</em> must be atomic in order for this function to work
reliably.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters40">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>address:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to an integer</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>lock_bit:</code></em></i>
		</p>
	</td>
		<td><p>a bit value between 0 and 31</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>



	<p>
	Since			: 2.24
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.30;" id="g_pointer_bit_trylock">
		
<h3 id="g_pointer_bit_trylock1">
	<span><code>g_pointer_bit_trylock</code></span>
</h3>

		

<pre class="prototype">
gboolean
g_pointer_bit_trylock (void* address,
                       gint lock_bit)</pre>

<p>This is equivalent to g_bit_trylock, but working on pointers (or
other pointer-sized values).</p>
<p>For portability reasons, you may only lock on the bottom 32 bits of
the pointer.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters41">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>address:</code></em></i>
		</p>
	</td>
		<td><p>a pointer to a gpointer-sized value</p>
</td>
<td>

<span class="annotation">[<abbr title="NULL is *not* OK, either for passing or returning"><span class="acronym">not nullable</span></abbr>]</span>

</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>lock_bit:</code></em></i>
		</p>
	</td>
		<td><p>a bit value between 0 and 31</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns15">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a> if the lock was acquired</p>

	</td>
	<td>
		gboolean
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>



	<p>
	Since			: 2.30
		</p>

</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="g_thread_self">
		
<h3 id="g_thread_self1">
	<span><code>g_thread_self</code></span>
</h3>

		

<pre class="prototype">
<a title="GThread" href="threads.html#GThread">GThread</a> *
g_thread_self ()</pre>

<p>This function returns the <a href="threads.html#GThread">GThread</a> corresponding to the
current thread. Note that this function does not increase
the reference count of the returned struct.</p>
<p>This function will return a <a href="threads.html#GThread">GThread</a> even for threads that
were not created by GLib (i.e. those created by other threading
APIs). This may be useful for thread identification purposes
(i.e. comparisons) but you must not use GLib functions (such
as <a href="threads.html#g_thread_join">g_thread_join</a>) on these threads.</p>


	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns16">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the <a href="threads.html#GThread">GThread</a> representing the current thread</p>

	</td>
	<td>
		<a title="GThread" href="threads.html#GThread">GThread</a> *
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>




            <h2 class="symbol_section" id="Function_Macros">Function Macros</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="G_UNLOCK">
		
<h3 id="g_unlock">
	<span><code>G_UNLOCK</code></span>
</h3>

		<pre class="raw_code">
#define G_UNLOCK(name) g_mutex_unlock   (&amp;G_LOCK_NAME (name))
</pre>

<p>Works like <a href="threads.html#g_mutex_unlock">g_mutex_unlock</a>, but for a lock defined with
<a href="threads.html#G_LOCK_DEFINE">G_LOCK_DEFINE</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters42">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>name:</code></em></i>
		</p>
	</td>
		<td><p>the name of the lock</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="G_LOCK_NAME">
		
<h3 id="g_lock_name">
	<span><code>G_LOCK_NAME</code></span>
</h3>

		<pre class="raw_code">
#define G_LOCK_NAME(name)             g__ ## name ## _lock
</pre>






</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="G_PRIVATE_INIT">
		
<h3 id="g_private_init">
	<span><code>G_PRIVATE_INIT</code></span>
</h3>

		<pre class="raw_code">
#define G_PRIVATE_INIT(notify) { NULL, (notify), { NULL, NULL } }
</pre>

<p>A macro to assist with the static initialisation of a <a href="threads.html#GPrivate">GPrivate</a>.</p>
<p>This macro is useful for the case that a <a href="datasets.html#GDestroyNotify">GDestroyNotify</a> function
should be associated the key.  This is needed when the key will be
used to point at memory that should be deallocated when the thread
exits.</p>
<p>Additionally, the <a href="datasets.html#GDestroyNotify">GDestroyNotify</a> will also be called on the previous
value stored in the key when <a href="threads.html#g_private_replace">g_private_replace</a> is used.</p>
<p>If no <a href="datasets.html#GDestroyNotify">GDestroyNotify</a> is needed, then use of this macro is not
required -- if the <a href="threads.html#GPrivate">GPrivate</a> is declared in static scope then it will
be properly initialised by default (ie: to all zeros).  See the
examples below.</p>
<pre><code class="language-[&lt;!--"> static GPrivate name_key = G_PRIVATE_INIT (g_free);

 // return value should not be freed
 const gchar *
 get_local_name (void)
 {
   return g_private_get (&amp;name_key);
 }

 void
 set_local_name (const gchar *name)
 {
   g_private_replace (&amp;name_key, g_strdup (name));
 }

 static GPrivate count_key;   // no free function

 gint
 get_local_count (void)
 {
   return GPOINTER_TO_INT (g_private_get (&amp;count_key));
 }

 void
 set_local_count (gint count)
 {
   g_private_set (&amp;count_key, GINT_TO_POINTER (count));
 }
</code></pre>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters43">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>notify:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="datasets.html#GDestroyNotify">GDestroyNotify</a></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="G_TRYLOCK">
		
<h3 id="g_trylock">
	<span><code>G_TRYLOCK</code></span>
</h3>

		<pre class="raw_code">
#define G_TRYLOCK(name) g_mutex_trylock (&amp;G_LOCK_NAME (name))
</pre>

<p>Works like <a href="threads.html#g_mutex_trylock">g_mutex_trylock</a>, but for a lock defined with
<a href="threads.html#G_LOCK_DEFINE">G_LOCK_DEFINE</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters44">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>name:</code></em></i>
		</p>
	</td>
		<td><p>the name of the lock</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns17">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p><a href="macros.html#TRUE">TRUE</a>, if the lock could be locked.</p>

	</td>
	<td>
		
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="g_once">
		
<h3 id="g_once1">
	<span><code>g_once</code></span>
</h3>

		<pre class="raw_code">
#define g_once(once, func, arg) \
  (((once)-&gt;status == G_ONCE_STATUS_READY) ? \
   (once)-&gt;retval : \
   g_once_impl ((once), (func), (arg)))
</pre>

<p>The first call to this routine by a process with a given <a href="threads.html#GOnce">GOnce</a>
struct calls <em>func</em> with the given argument. Thereafter, subsequent
calls to <a href="threads.html#g_once">g_once</a>  with the same <a href="threads.html#GOnce">GOnce</a> struct do not call <em>func</em>
again, but return the stored result of the first call. On return
from <a href="threads.html#g_once">g_once</a>, the status of <em>once</em> will be <a href="threads.html#G_ONCE_STATUS_READY">G_ONCE_STATUS_READY</a>.</p>
<p>For example, a mutex or a thread-specific data key must be created
exactly once. In a threaded environment, calling <a href="threads.html#g_once">g_once</a> ensures
that the initialization is serialized across multiple threads.</p>
<p>Calling <a href="threads.html#g_once">g_once</a> recursively on the same <a href="threads.html#GOnce">GOnce</a> struct in
<em>func</em> will lead to a deadlock.</p>
<pre><code class="language-[&lt;!--">   gpointer
   get_debug_flags (void)
   {
     static GOnce my_once = G_ONCE_INIT;

     g_once (&amp;my_once, parse_debug_flags, NULL);

     return my_once.retval;
   }
</code></pre>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters45">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>once:</code></em></i>
		</p>
	</td>
		<td><p>a <a href="threads.html#GOnce">GOnce</a> structure</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>func:</code></em></i>
		</p>
	</td>
		<td><p>the <a href="threads.html#GThreadFunc">GThreadFunc</a> function associated to <em>once</em>. This function
is called only once, regardless of the number of times it and
its associated <a href="threads.html#GOnce">GOnce</a> struct are passed to <a href="threads.html#g_once">g_once</a>.</p>
</td>
<td>


</td>
</tr>

									<tr>
		<td>
		<p>
		<i><em><code>arg:</code></em></i>
		</p>
	</td>
		<td><p>data to be passed to <em>func</em></p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="G_LOCK_DEFINE_STATIC">
		
<h3 id="g_lock_define_static">
	<span><code>G_LOCK_DEFINE_STATIC</code></span>
</h3>

		<pre class="raw_code">
#define G_LOCK_DEFINE_STATIC(name)    static G_LOCK_DEFINE (name)
</pre>

<p>This works like <a href="threads.html#G_LOCK_DEFINE">G_LOCK_DEFINE</a>, but it creates a static object.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters46">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>name:</code></em></i>
		</p>
	</td>
		<td><p>the name of the lock</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="G_LOCK">
		
<h3 id="g_lock">
	<span><code>G_LOCK</code></span>
</h3>

		<pre class="raw_code">
#define G_LOCK(name) g_mutex_lock       (&amp;G_LOCK_NAME (name))
</pre>

<p>Works like <a href="threads.html#g_mutex_lock">g_mutex_lock</a>, but for a lock defined with
<a href="threads.html#G_LOCK_DEFINE">G_LOCK_DEFINE</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters47">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>name:</code></em></i>
		</p>
	</td>
		<td><p>the name of the lock</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="G_LOCK_DEFINE">
		
<h3 id="g_lock_define">
	<span><code>G_LOCK_DEFINE</code></span>
</h3>

		<pre class="raw_code">
#define G_LOCK_DEFINE(name)           GMutex G_LOCK_NAME (name)
</pre>

<p>The G_LOCK_ macros provide a convenient interface to GMutex.
<a href="threads.html#G_LOCK_DEFINE">G_LOCK_DEFINE</a> defines a lock. It can appear in any place where
variable definitions may appear in programs, i.e. in the first block
of a function or outside of functions. The <em>name</em> parameter will be
mangled to get the name of the GMutex. This means that you
can use names of existing variables as the parameter - e.g. the name
of the variable you intend to protect with the lock. Look at our
give_me_next_number example using the <a href="threads.html#G_LOCK">G_LOCK</a> macros:</p>
<p>Here is an example for using the <a href="threads.html#G_LOCK">G_LOCK</a> convenience macros:</p>
<pre><code class="language-[&lt;!--">   G_LOCK_DEFINE (current_number);

   int
   give_me_next_number (void)
   {
     static int current_number = 0;
     int ret_val;

     G_LOCK (current_number);
     ret_val = current_number = calc_next_number (current_number);
     G_UNLOCK (current_number);

     return ret_val;
   }
</code></pre>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters48">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>name:</code></em></i>
		</p>
	</td>
		<td><p>the name of the lock</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="G_LOCK_EXTERN">
		
<h3 id="g_lock_extern">
	<span><code>G_LOCK_EXTERN</code></span>
</h3>

		<pre class="raw_code">
#define G_LOCK_EXTERN(name)           extern GMutex G_LOCK_NAME (name)
</pre>

<p>This declares a lock, that is defined with <a href="threads.html#G_LOCK_DEFINE">G_LOCK_DEFINE</a> in another
module.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters49">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>name:</code></em></i>
		</p>
	</td>
		<td><p>the name of the lock</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>




</div>




            <h2 class="symbol_section" id="Structures">Structures</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="GOnce">
		
<h3 id="struct-gonce">
		struct GOnce
	</h3>

		<pre class="raw_code">
struct GOnce {
    volatile GOnceStatus status;
    volatile gpointer retval;
};
</pre>

<p>A <a href="threads.html#GOnce">GOnce</a> struct controls a one-time initialization function. Any
one-time initialization function must have its own unique <a href="threads.html#GOnce">GOnce</a>
struct.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="fields">Fields</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr id="GOnce.status">
		<td>
		<p>
		<i><em><code>volatile <a title="GOnceStatus" href="threads.html#GOnceStatus">GOnceStatus</a> <em><code>status</code></em>:</code></em></i>
		</p>
	</td>
		<td><p>the status of the <a href="threads.html#GOnce">GOnce</a></p>
</td>
</tr>

						<tr id="GOnce.retval">
		<td>
		<p>
		<i><em><code>volatile gpointer <em><code>retval</code></em>:</code></em></i>
		</p>
	</td>
		<td><p>the value returned by the call to the function, if <em>status</em>
is <a href="threads.html#G_ONCE_STATUS_READY">G_ONCE_STATUS_READY</a></p>
</td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="GRecMutex">
		
<h3 id="struct-grecmutex">
		struct GRecMutex
	</h3>

		<pre class="raw_code">
struct GRecMutex {
    gpointer p; /* &lt; private &gt; */
    guint i; /* &lt; private &gt; */
};
</pre>

<p>The GRecMutex struct is an opaque data structure to represent a
recursive mutex. It is similar to a GMutex with the difference
that it is possible to lock a GRecMutex multiple times in the same
thread without deadlock. When doing so, care has to be taken to
unlock the recursive mutex as often as it has been locked.</p>
<p>If a <a href="threads.html#GRecMutex">GRecMutex</a> is allocated in static storage then it can be used
without initialisation.  Otherwise, you should call
<a href="threads.html#g_rec_mutex_init">g_rec_mutex_init</a> on it and <a href="threads.html#g_rec_mutex_clear">g_rec_mutex_clear</a> when done.</p>
<p>A GRecMutex should only be accessed with the
g_rec_mutex_ functions.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="fields1">Fields</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr id="GRecMutex.p">
		<td>
		<p>
		<i><em><code>gpointer <em><code>p</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GRecMutex.i">
		<td>
		<p>
		<i><em><code>guint <em><code>i</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="GCond">
		
<h3 id="struct-gcond">
		struct GCond
	</h3>

		<pre class="raw_code">
struct GCond {
    gpointer p; /* &lt; private &gt; */
    guint i; /* &lt; private &gt; */
};
</pre>

<p>The <a href="threads.html#GCond">GCond</a> struct is an opaque data structure that represents a
condition. Threads can block on a <a href="threads.html#GCond">GCond</a> if they find a certain
condition to be false. If other threads change the state of this
condition they signal the <a href="threads.html#GCond">GCond</a>, and that causes the waiting
threads to be woken up.</p>
<p>Consider the following example of a shared variable.  One or more
threads can wait for data to be published to the variable and when
another thread publishes the data, it can signal one of the waiting
threads to wake up to collect the data.</p>
<p>Here is an example for using GCond to block a thread until a condition
is satisfied:</p>
<pre><code class="language-[&lt;!--">   gpointer current_data = NULL;
   GMutex data_mutex;
   GCond data_cond;

   void
   push_data (gpointer data)
   {
     g_mutex_lock (&amp;data_mutex);
     current_data = data;
     g_cond_signal (&amp;data_cond);
     g_mutex_unlock (&amp;data_mutex);
   }

   gpointer
   pop_data (void)
   {
     gpointer data;

     g_mutex_lock (&amp;data_mutex);
     while (!current_data)
       g_cond_wait (&amp;data_cond, &amp;data_mutex);
     data = current_data;
     current_data = NULL;
     g_mutex_unlock (&amp;data_mutex);

     return data;
   }
</code></pre>
<p>Whenever a thread calls pop_data now, it will wait until
current_data is non-%NULL, i.e. until some other thread
has called push_data.</p>
<p>The example shows that use of a condition variable must always be
paired with a mutex.  Without the use of a mutex, there would be a
race between the check of <em>current_data</em> by the while loop in
pop_data and waiting. Specifically, another thread could set
<em>current_data</em> after the check, and signal the cond (with nobody
waiting on it) before the first thread goes to sleep. <a href="threads.html#GCond">GCond</a> is
specifically useful for its ability to release the mutex and go
to sleep atomically.</p>
<p>It is also important to use the <a href="threads.html#g_cond_wait">g_cond_wait</a> and <a href="threads.html#g_cond_wait_until">g_cond_wait_until</a>
functions only inside a loop which checks for the condition to be
true.  See <a href="threads.html#g_cond_wait">g_cond_wait</a> for an explanation of why the condition may
not be true even after it returns.</p>
<p>If a <a href="threads.html#GCond">GCond</a> is allocated in static storage then it can be used
without initialisation.  Otherwise, you should call <a href="threads.html#g_cond_init">g_cond_init</a>
on it and <a href="threads.html#g_cond_clear">g_cond_clear</a> when done.</p>
<p>A <a href="threads.html#GCond">GCond</a> should only be accessed via the g_cond_ functions.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="fields2">Fields</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr id="GCond.p">
		<td>
		<p>
		<i><em><code>gpointer <em><code>p</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GCond.i">
		<td>
		<p>
		<i><em><code>guint <em><code>i</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="GThread">
		
<h3 id="struct-gthread">
		struct GThread
	</h3>

		<pre class="raw_code">
struct GThread {
};
</pre>

<p>The <a href="threads.html#GThread">GThread</a> struct represents a running thread. This struct
is returned by <a href="threads.html#g_thread_new">g_thread_new</a> or <a href="threads.html#g_thread_try_new">g_thread_try_new</a>. You can
obtain the <a href="threads.html#GThread">GThread</a> struct representing the current thread by
calling <a href="threads.html#g_thread_self">g_thread_self</a>.</p>
<p>GThread is refcounted, see <a href="threads.html#g_thread_ref">g_thread_ref</a> and <a href="threads.html#g_thread_unref">g_thread_unref</a>.
The thread represented by it holds a reference while it is running,
and <a href="threads.html#g_thread_join">g_thread_join</a> consumes the reference that it is given, so
it is normally not necessary to manage GThread references
explicitly.</p>
<p>The structure is opaque -- none of its fields may be directly
accessed.</p>




</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="GPrivate">
		
<h3 id="struct-gprivate">
		struct GPrivate
	</h3>

		<pre class="raw_code">
struct GPrivate {
    gpointer p; /* &lt; private &gt; */
    GDestroyNotify notify; /* &lt; private &gt; */
    gpointer future; /* &lt; private &gt; */
};
</pre>

<p>The <a href="threads.html#GPrivate">GPrivate</a> struct is an opaque data structure to represent a
thread-local data key. It is approximately equivalent to the
pthread_setspecific/pthread_getspecific APIs on POSIX and to
TlsSetValue/TlsGetValue on Windows.</p>
<p>If you don't already know why you might want this functionality,
then you probably don't need it.</p>
<p><a href="threads.html#GPrivate">GPrivate</a> is a very limited resource (as far as 128 per program,
shared between all libraries). It is also not possible to destroy a
<a href="threads.html#GPrivate">GPrivate</a> after it has been used. As such, it is only ever acceptable
to use <a href="threads.html#GPrivate">GPrivate</a> in static scope, and even then sparingly so.</p>
<p>See <a href="threads.html#G_PRIVATE_INIT">G_PRIVATE_INIT</a> for a couple of examples.</p>
<p>The <a href="threads.html#GPrivate">GPrivate</a> structure should be considered opaque.  It should only
be accessed via the g_private_ functions.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="fields3">Fields</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr id="GPrivate.p">
		<td>
		<p>
		<i><em><code>gpointer <em><code>p</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GPrivate.notify">
		<td>
		<p>
		<i><em><code><a title="GDestroyNotify" href="datasets.html#GDestroyNotify">GDestroyNotify</a> <em><code>notify</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GPrivate.future">
		<td>
		<p>
		<i><em><code>gpointer <em><code>future</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.32;" id="GRWLock">
		
<h3 id="struct-grwlock">
		struct GRWLock
	</h3>

		<pre class="raw_code">
struct GRWLock {
    gpointer p; /* &lt; private &gt; */
    guint i; /* &lt; private &gt; */
};
</pre>

<p>The GRWLock struct is an opaque data structure to represent a
reader-writer lock. It is similar to a GMutex in that it allows
multiple threads to coordinate access to a shared resource.</p>
<p>The difference to a mutex is that a reader-writer lock discriminates
between read-only ('reader') and full ('writer') access. While only
one thread at a time is allowed write access (by holding the 'writer'
lock via <a href="threads.html#g_rw_lock_writer_lock">g_rw_lock_writer_lock</a>), multiple threads can gain
simultaneous read-only access (by holding the 'reader' lock via
<a href="threads.html#g_rw_lock_reader_lock">g_rw_lock_reader_lock</a>).</p>
<p>Here is an example for an array with access functions:</p>
<pre><code class="language-[&lt;!--">   GRWLock lock;
   GPtrArray *array;

   gpointer
   my_array_get (guint index)
   {
     gpointer retval = NULL;

     if (!array)
       return NULL;

     g_rw_lock_reader_lock (&amp;lock);
     if (index &lt; array-&gt;len)
       retval = g_ptr_array_index (array, index);
     g_rw_lock_reader_unlock (&amp;lock);

     return retval;
   }

   void
   my_array_set (guint index, gpointer data)
   {
     g_rw_lock_writer_lock (&amp;lock);

     if (!array)
       array = g_ptr_array_new ();

     if (index &gt;= array-&gt;len)
       g_ptr_array_set_size (array, index+1);
     g_ptr_array_index (array, index) = data;

     g_rw_lock_writer_unlock (&amp;lock);
   }
</code></pre>
<p>This example shows an array which can be accessed by many readers
(the my_array_get function) simultaneously, whereas the writers
(the my_array_set function) will only be allowed one at a time
and only if no readers currently access the array. This is because
of the potentially dangerous resizing of the array. Using these
functions is fully multi-thread safe now.</p>
<p>If a <a href="threads.html#GRWLock">GRWLock</a> is allocated in static storage then it can be used
without initialisation.  Otherwise, you should call
<a href="threads.html#g_rw_lock_init">g_rw_lock_init</a> on it and <a href="threads.html#g_rw_lock_clear">g_rw_lock_clear</a> when done.</p>
<p>A GRWLock should only be accessed with the g_rw_lock_ functions.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="fields4">Fields</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr id="GRWLock.p">
		<td>
		<p>
		<i><em><code>gpointer <em><code>p</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						<tr id="GRWLock.i">
		<td>
		<p>
		<i><em><code>guint <em><code>i</code></em>:</code></em></i>
		</p>
	</td>
		<td></td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>




            <h2 class="symbol_section" id="Enumerations">Enumerations</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="GOnceStatus">
		
<h3 id="enum-goncestatus">
		enum GOnceStatus
	</h3>

		<p>The possible statuses of a one-time initialization function
controlled by a <a href="threads.html#GOnce">GOnce</a> struct.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="members">Members</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr>
	<td>
		<p>
		<a id="G_ONCE_STATUS_NOTCALLED"></a>
		G_ONCE_STATUS_NOTCALLED
		</p>
	</td>
	<td><p>the function has not been called yet.</p>
</td>
	<td>
		<span class="value">Value: 0</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_ONCE_STATUS_PROGRESS"></a>
		G_ONCE_STATUS_PROGRESS
		</p>
	</td>
	<td><p>the function call is currently in progress.</p>
</td>
	<td>
		<span class="value">Value: 1</span>
	</td>
</tr>

						<tr>
	<td>
		<p>
		<a id="G_ONCE_STATUS_READY"></a>
		G_ONCE_STATUS_READY
		</p>
	</td>
	<td><p>the function has been called.</p>
</td>
	<td>
		<span class="value">Value: 2</span>
	</td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="" id="GThreadError">
		
<h3 id="enum-gthreaderror">
		enum GThreadError
	</h3>

		<p>Possible errors of thread related functions.</p>


<div class="member_details">
	
	<h4 class="always-hide-toc" data-toc-skip="true" id="members1">Members</h4>
	<div class="member_container">
		<table>
			<tbody>
						<tr>
	<td>
		<p>
		<a id="G_THREAD_ERROR_AGAIN"></a>
		G_THREAD_ERROR_AGAIN
		</p>
	</td>
	<td><p>a thread couldn't be created due to resource
shortage. Try again later.</p>
</td>
	<td>
		<span class="value">Value: 0</span>
	</td>
</tr>

						</tbody>
		</table>
	</div>
</div>


</div>




            <h2 class="symbol_section" id="Constants">Constants</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="G_THREAD_ERROR">
		
<h3 class="constant" id="g_thread_error">
	G_THREAD_ERROR
</h3>

		<pre class="raw_code">
#define G_THREAD_ERROR g_thread_error_quark ()
</pre>

<p>The error domain of the GLib thread subsystem.</p>


</div>

            

<div class="base_symbol_container" data-hotdoc-tags="since:2.4;" id="G_ONCE_INIT">
		
<h3 class="constant" id="g_once_init">
	G_ONCE_INIT
</h3>

		<pre class="raw_code">
#define G_ONCE_INIT { G_ONCE_STATUS_NOTCALLED, NULL }
</pre>

<p>A <a href="threads.html#GOnce">GOnce</a> must be initialized with this macro before it can be used.</p>
<pre><code class="language-[&lt;!--">   GOnce my_once = G_ONCE_INIT;
</code></pre>


</div>




            <h2 class="symbol_section" id="Aliases">Aliases</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="since:2.44;" id="GMutexLocker">
		
<h3 id="gmutexlocker1">
	GMutexLocker
</h3>

		<pre>
typedef gpointer GMutexLocker</pre>
<p>Opaque type. See g_mutex_locker_new for details.</p>


</div>




            <h2 class="symbol_section" id="Callbacks">Callbacks</h2>
                    

<div class="base_symbol_container" data-hotdoc-tags="" id="GThreadFunc">
		
<h3 id="gthreadfunc">
	<span><code>GThreadFunc</code></span>
</h3>

		

<pre class="prototype">
gpointer
(*GThreadFunc) (gpointer data)</pre>

<p>Specifies the type of the <em>func</em> functions passed to <a href="threads.html#g_thread_new">g_thread_new</a>
or <a href="threads.html#g_thread_try_new">g_thread_try_new</a>.</p>


	<div class="parameter_container">
		<h4 class="always-hide-toc" data-toc-skip="true" id="parameters50">Parameters</h4>
		<table>
			<tbody>
									<tr>
		<td>
		<p>
		<i><em><code>data:</code></em></i>
		</p>
	</td>
		<td><p>data passed to the thread</p>
</td>
<td>


</td>
</tr>

							</tbody>
		</table>
	</div>

	<div class="multi_return_value_container">
	
			<h4 class="always-hide-toc" data-toc-skip="true" id="returns18">Returns:</h4>
		<table>
		<colgroup>
			<col>
			<col>
			<col>
		</colgroup>
		<tbody>
						<tr>
	<td>
		<p>
				</p>
	</td>
	<td>
		<p>the return value of the thread</p>

	</td>
	<td>
		gpointer
	</td>
				<td>
	

	</td>
		</tr>

					</tbody>
	</table>
</div>




</div>






		<div id="subpages"></div>
		</div>
		<div id="search_results">
			<p>The results of the search are</p>
		</div>
	</div>

</div>

<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2">
	<div id="toc-column">
		
					<div class="edit-button">
				

			</div>
				<div id="toc-wrapper">
			<nav id="toc"></nav>
		</div>
	</div>
</div>
	</div>

</main>


<footer class="page-row">
	<div class="container-fluid">
	<div class="row">
		<div class="hidden-xs hidden-sm col-md-3 col-lg-3 col-xl-2" id="footer-left-column"></div>
		<div class="col-xs-12 col-sm-12 col-md-9 col-lg-7 col-xl-8" id="footer-content-column">
						    

		</div>
		<div class="hidden-xs hidden-sm hidden-md col-lg-2 col-xl-2" id="footer-right-column"></div>
	</div>
</div>
</footer>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>